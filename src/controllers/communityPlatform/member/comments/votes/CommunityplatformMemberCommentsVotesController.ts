import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { postCommunityPlatformMemberCommentsCommentIdVotes } from "../../../../../providers/postCommunityPlatformMemberCommentsCommentIdVotes";
import { MemberAuth } from "../../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../../decorators/payload/MemberPayload";
import { patchCommunityPlatformMemberCommentsCommentIdVotes } from "../../../../../providers/patchCommunityPlatformMemberCommentsCommentIdVotes";
import { deleteCommunityPlatformMemberCommentsCommentIdVotes } from "../../../../../providers/deleteCommunityPlatformMemberCommentsCommentIdVotes";

import { ICommunityPlatformCommentVoteResponse } from "../../../../../api/structures/ICommunityPlatformCommentVoteResponse";
import { ICommunityPlatformCommentVoteRequest } from "../../../../../api/structures/ICommunityPlatformCommentVoteRequest";

@Controller("/communityPlatform/member/comments/:commentId/votes")
export class CommunityplatformMemberCommentsVotesController {
  /**
   * Create a new vote on a comment.
   *
   * This operation allows an authenticated member to establish a new vote on a
   * comment for the first time. When a user clicks an upvote or downvote button
   * and has no prior vote on the comment, this operation is called to create a
   * vote record.
   *
   * The operation enforces the business rule that users cannot vote on comments
   * they authored; such attempts are blocked server-side with a 403 error and
   * the message: "You can't vote on your own posts/comments." Guests attempting
   * to vote are redirected to login with a "Please sign in to continue."
   * message.
   *
   * The vote_state field in the request body must be either 'upvote' or
   * 'downvote'. The server validates that this is a new vote (no existing vote
   * record from the user for this comment). Upon success, a new vote record is
   * created with the user ID, comment ID, and vote state. The vote score for
   * the comment is updated server-side and propagated to all feed views.
   *
   * This operation follows optimistic UI pattern: the UI updates the vote
   * button state and comment score immediately upon user interaction. If server
   * synchronization fails, the UI reverts to its previous state and displays:
   * "A temporary error occurred. Please try again in a moment."
   *
   * This operation is used during the initial vote action, while the PATCH
   * operation is used for modifying existing votes. The system does not allow a
   * user to create multiple votes on the same comment; existing votes are
   * always updated, not duplicated.
   *
   * @param connection
   * @param commentId Unique identifier of the target comment in UUID format.
   * @param body The vote state to create for this comment on behalf of the
   *   authenticated user. Must be either 'upvote' or 'downvote'.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommentVoteRequest,
  ): Promise<ICommunityPlatformCommentVoteResponse> {
    try {
      return await postCommunityPlatformMemberCommentsCommentIdVotes({
        member,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update a vote on a comment with new state.
   *
   * This operation allows a member to change their existing vote on a comment.
   * Users may only vote on comments they have already voted on, toggling
   * between upvote, downvote, and none states. The vote state transition
   * follows the pattern: None → Upvote → Downvote → None, or direct switches
   * between Upvote and Downvote.
   *
   * The operation is only available to registered members; guests attempting to
   * vote are redirected to login. The system enforces the business rule that
   * users cannot vote on their own comments. If a user attempts to vote on a
   * comment they authored, the operation returns an error response with the
   * message: "You can't vote on your own posts/comments."
   *
   * This operation performs an optimistic UI update: when the user clicks the
   * vote button, the UI immediately reflects the new vote state (color change
   * and score update) before the server confirms the change. If the server
   * returns an error, the UI reverts to the previous state and shows: "A
   * temporary error occurred. Please try again in a moment."
   *
   * The request body contains the new vote_state ('upvote' or 'downvote') as
   * the switch mechanism; sending a vote state that matches the current vote
   * will delete the vote record (set to 'none'). The comment's score is
   * recalculated server-side and used for the Top sort ordering in feeds and
   * search results.
   *
   * @param connection
   * @param commentId Unique identifier of the target comment in UUID format.
   * @param body The new vote state to apply to the comment. Only 'upvote' or
   *   'downvote' values are accepted. If the submitted state matches the
   *   current state, the vote should be removed (set to none).
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommentVoteRequest,
  ): Promise<ICommunityPlatformCommentVoteResponse> {
    try {
      return await patchCommunityPlatformMemberCommentsCommentIdVotes({
        member,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Remove a vote from a comment.
   *
   * This operation removes the current vote from a comment if the user has
   * already voted on it. When the user re-clicks their current voting button
   * (e.g., clicking the Upvote button when already upvoted), this operation is
   * triggered to delete the vote record and revert the vote state to 'none'.
   *
   * This operation follows the same security rules as vote creation and update:
   * only authenticated members may perform it; guests are redirected to login,
   * and users cannot vote on their own comments. The server ensures only one
   * vote record can exist per user-comment pair, so a DELETE request is the
   * mechanism for removing a vote.
   *
   * The operation does not require a request body — the identification of the
   * comment and user context is sufficient. If the user has no existing vote on
   * the comment, the server returns a 404 error confirming no vote exists to
   * delete.
   *
   * This operation is the mechanism for setting a vote state back to 'none'. It
   * is used in conjunction with POST and PATCH to provide a complete vote
   * lifecycle: POST (set first vote), PATCH (modify vote), DELETE (remove
   * vote). The comment score is decremented accordingly on the server, and the
   * UI is updated optimistically before sync.
   *
   * @param connection
   * @param commentId Unique identifier of the target comment in UUID format.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformCommentVoteResponse> {
    try {
      return await deleteCommunityPlatformMemberCommentsCommentIdVotes({
        member,
        commentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
