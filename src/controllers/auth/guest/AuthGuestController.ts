import { Controller } from "@nestjs/common";
import { TypedRoute, TypedBody } from "@nestia/core";
import typia from "typia";
import { postauthGuestJoin } from "../../../providers/postauthGuestJoin";
import { GuestAuth } from "../../../decorators/GuestAuth";
import { GuestPayload } from "../../../decorators/payload/GuestPayload";
import { postauthGuestRefresh } from "../../../providers/postauthGuestRefresh";

import { ICommunitybbsMember } from "../../../api/structures/ICommunitybbsMember";

@Controller("/auth/guest")
export class AuthGuestController {
  /**
   * Registers a guest user as a member by creating a new member record and
   * issuing initial JWT tokens.
   *
   * This authorization operation enables unauthenticated guests to register as
   * members of the Community BBS platform. The operation is triggered when a
   * user initiates the account creation flow, translating the guest state into
   * a persistent member identity. The implementation is governed by the
   * communitybbs_member data model, which enforces strict requirements: the
   * email field must be unique and contain a valid email format; the
   * password_hash is securely stored using BCrypt encryption; and the
   * display_name is mandatory, defaulting to "Anonymous" if not provided. The
   * operation creates a new record in the communitybbs_member table with the
   * submitted credentials, automatically generating a unique UUID for the id
   * field. Concurrently, a corresponding session record is initiated in the
   * communitybbs_session table with a cryptographically secure token, an
   * expiration timestamp, and an active status marked as true. The operation
   * references no fields beyond those defined in the communitybbs_member
   * schema, meaning it does not rely on or update any denormalized fields such
   * as last_active_at or updated_at, as those are handled by the application
   * layer following successful creation. This flow integrates directly with the
   * platform's authentication workflow, where a successful join operation
   * immediately provides access to all member-only functionalities including
   * posting, commenting, voting, and community joining. The operation does not
   * support password recovery or token refresh; those are separate concerns
   * handled by their own dedicated endpoints. Security considerations include
   * ensuring password hashes are never transmitted in plaintext and that
   * validation is performed strictly server-side. The operation is stateless
   * and idempotent, meaning repeated execution with identical credentials will
   * fail due to the unique email constraint. A successful response will include
   * the newly generated member's email and display_name in the response body,
   * formatted as ICommunitybbsMember.IAuthorized, following the required DTO
   * naming pattern for authentication operations. This operation is the only
   * authorized path for a guest to transition into a member, and all other user
   * interactions are blocked until this step is successfully completed.
   *
   * @param connection
   * @param body Request body for registering a new member from guest state.
   *   Contains required credentials and optional display preferences.
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("join")
  public async join(
    @GuestAuth()
    guest: GuestPayload,
    @TypedBody()
    body: ICommunitybbsMember.ICreate,
  ): Promise<ICommunitybbsMember.IAuthorized> {
    try {
      return await postauthGuestJoin({
        guest,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Refreshes a temporary session token for a guest user to maintain anonymous
   * access.
   *
   * This authorization operation permits authenticated guest users to extend
   * their temporary access duration by refreshing the session token, without
   * requiring credentials. Guests, by definition, do not authenticate with
   * email/password but are assigned temporary token-based sessions to maintain
   * state during their anonymous browsing. This operation references the
   * communitybbs_session table exclusively, validating the provided refresh
   * token against the token field and checking its expires_at and is_valid
   * fields. When valid, the system generates a new set of tokens, updates the
   * last_activity_at field to the current timestamp to extend session
   * viability, and returns a new token pair. No fields from the
   * communitybbs_guest table are modified during this operation, as the guest
   * entity only stores immutable data like ip_address and display_name. This
   * operation does not perform any validation on the email or password fields
   * because these do not exist for guest users. The refresh process is
   * stateless and token-bound, relying entirely on the integrity of the token
   * stored in the session record. This operation is crucial for maintaining a
   * fluid user experience as described in the functional requirements, allowing
   * guests to browse for extended periods without login interruptions. The
   * operation responds with a new token set that must be used for subsequent
   * requests; the previously issued tokens are immediately invalidated. This
   * endpoint is protected only by the correctness of the token itself, not by
   * any user credentials, and follows the authentication workflow defined for
   * non-authenticated sessions. Response body follows the
   * ICommunitybbsMember.IAuthorized pattern to maintain consistency in token
   * responses across guest and member flows, even though no member entity
   * exists.
   *
   * @param connection
   * @setHeader token.access Authorization
   *
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post("refresh")
  public async refresh(
    @GuestAuth()
    guest: GuestPayload,
  ): Promise<ICommunitybbsMember.IAuthorized> {
    try {
      return await postauthGuestRefresh({
        guest,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
