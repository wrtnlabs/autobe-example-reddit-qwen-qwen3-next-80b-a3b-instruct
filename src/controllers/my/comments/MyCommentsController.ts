import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { putmyCommentsCommentId } from "../../../providers/putmyCommentsCommentId";
import { MemberAuth } from "../../../decorators/MemberAuth";
import { MemberPayload } from "../../../decorators/payload/MemberPayload";
import { deletemyCommentsCommentId } from "../../../providers/deletemyCommentsCommentId";

import { IComment } from "../../../api/structures/IComment";

@Controller("/my/comments/:commentId")
export class MyCommentsController {
  /**
   * Update the content of a user's own comment.
   *
   * This operation allows a member to edit the content of a comment they
   * authored. The system verifies that the authenticated member's id matches
   * the communitybbs_member_id in the specified comment record in the
   * communitybbs_comment table. It then updates the content field with the new
   * value, ensuring it is between 2 and 2,000 characters as per schema
   * constraints. The updated_at timestamp is set to the current time. The
   * parent and post associations remain unchanged. The display_name is
   * preserved from the original record. This behavior is supported by the
   * schema's structure, which includes a writable updated_at field and the
   * ability to modify the content column. This supports requirements that
   * members can correct typos or clarify their comments. The edit triggers an
   * asynchronous update to the communitybbs_search_comment index to maintain
   * search relevance.
   *
   * @param connection
   * @param commentId The unique identifier of the comment to be updated. Must
   *   match an existing communitybbs_comment.id and the comment must have been
   *   authored by the authenticated member.
   * @param body Request body containing the new comment content.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put()
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: IComment.IUpdate,
  ): Promise<IComment> {
    try {
      return await putmyCommentsCommentId({
        member,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Permanently delete a user's own comment (soft delete).
   *
   * This operation allows a member to delete a comment they authored. Upon
   * execution, it performs a soft delete by updating the deleted_at field in
   * the communitybbs_comment table to the current timestamp. This preserves the
   * comment's data for audit and moderation purposes while hiding it from
   * regular views. The system validates that the authenticated member's id
   * matches the communitybbs_member_id of the desired comment. This assertion
   * ensures no user can delete others' comments. The soft delete behavior is
   * enabled by the presence of the deleted_at column in the
   * communitybbs_comment table in the Prisma schema, which is configured as a
   * nullable DateTime. This is consistent with the business requirement that
   * users can delete only their own content. Associated votes for the comment
   * are also logically removed via cascading relationships. This operation does
   * not affect the search index although it will be updated asynchronously by
   * the search service.
   *
   * @param connection
   * @param commentId The unique identifier of the comment to be deleted. Must
   *   match an existing communitybbs_comment.id and the comment must have been
   *   authored by the authenticated member.
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete()
  public async erase(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await deletemyCommentsCommentId({
        member,
        commentId,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
