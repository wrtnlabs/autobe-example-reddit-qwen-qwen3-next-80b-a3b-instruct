import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { patchcommunitiesCommunityIdPostsPostIdVotes } from "../../../../providers/patchcommunitiesCommunityIdPostsPostIdVotes";
import { MemberAuth } from "../../../../decorators/MemberAuth";
import { MemberPayload } from "../../../../decorators/payload/MemberPayload";

import { ICommunitybbsVote } from "../../../../api/structures/ICommunitybbsVote";

@Controller("/communities/:communityId/posts/:postId/votes")
export class CommunitiesPostsVotesController {
  /**
   * Update a vote on a post.
   *
   * This operation enables authenticated members to update their vote on a
   * post. If the user has not voted on the post, a new vote is created. If they
   * have voted and the new vote matches their previous vote, the vote is
   * removed (set to 'none'). If they switch from upvote to downvote, or vice
   * versa, the previous vote is overwritten with the new one.
   *
   * The system enforces that users cannot vote on their own post, as specified
   * in the business rule: "You can't vote on your own posts/comments." This is
   * validated by comparing the authenticated user's ID with the
   * communitybbs_member_id of the post. If the user is the post author, the
   * operation will be denied with a 403 error.
   *
   * The vote does not have a comment or additional context field; it is purely
   * binary. The post score (upvotes - downvotes) is calculated dynamically at
   * query time from this table, and no aggregated field exists in the post
   * table itself, maintaining data normalization.
   *
   * This operation does not require the communityId for the voting logic
   * itself, but it is included in the path for context and consistency with the
   * resource hierarchy, enabling proper authorization and validation checks
   * against community ownership. The request body must contain the vote type as
   * 'upvote' or 'downvote'.
   *
   * The system automatically logs vote actions in the communitybbs_log table as
   * a side effect, but manual API access to these logs is not provided,
   * consistent with system-generated audit trail policy.
   *
   * @param connection
   * @param communityId Unique identifier of the target community containing the
   *   post
   * @param postId Unique identifier of the target post to be voted on
   * @param body The type of vote to update on the post: 'upvote' or 'downvote'
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async update(
    @MemberAuth()
    member: MemberPayload,
    @TypedParam("communityId")
    communityId: string & tags.Format<"uuid">,
    @TypedParam("postId")
    postId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunitybbsVote.IUpdate,
  ): Promise<ICommunitybbsVote> {
    try {
      return await patchcommunitiesCommunityIdPostsPostIdVotes({
        member,
        communityId,
        postId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
