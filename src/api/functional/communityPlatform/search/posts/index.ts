import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
import { IPageICommunityPlatformPost } from "../../../../structures/IPageICommunityPlatformPost";

/**
 * Search for posts using keywords with sorting and pagination options.
 *
 * This endpoint supports the comprehensive post search functionality on the
 * platform's /s page, specifically targeting the 'Posts' tab. It queries the
 * community_platform_search_posts materialized view, which contains
 * denormalized data from community_platform_posts and corresponding statistics
 * from community_platform_post_stats to enable efficient full-text search and
 * sorting without expensive joins at query time.
 *
 * The operation accepts a request body with parameters for search query (q),
 * sort order (newest or top), pagination (page and limit), and optional
 * community filters. The search query is matched against the title and body
 * fields in the search view using PostgreSQL's pg_trgm extension for fuzzy
 * matching. When the sort parameter is 'newest', results are ordered by
 * created_at descending. When the sort parameter is 'top', results are ordered
 * by score (upvotes - downvotes) descending, followed by created_at descending,
 * and then by post identifier descending for tie-breaking.
 *
 * The operation returns a paginated result set of 20 posts per page, as
 * specified in the requirements. Each post in the response includes essential
 * summary data: community name, post title, author display name (or
 * 'Anonymous'), creation timestamp (presented in relative format per client
 * context), comment count, and current score. The response body uses the
 * IPageICommunityPlatformPost type schema, which includes a pagination metadata
 * object and the data array.
 *
 * This endpoint enforces the requirement that search queries must be at least 2
 * characters; if a shorter query is provided, the API returns a 400 Bad Request
 * response with a message indicating the minimum length requirement. This
 * validation occurs before any database query is executed for performance
 * optimization. If no results match the criteria, an empty data array is
 * returned with pagination details indicating zero total results.
 *
 * As this is a complex search operation utilizing a request body for query
 * parameters, the HTTP PATCH method is used in accordance with the API design
 * principle for complex collection searches, even though no data is modified on
 * the server. The user's authentication status (guest or member) affects the
 * visibility of join buttons in the UI but does not affect the search results
 * themselves, as all post content is publicly accessible for reading.
 *
 * @param props.connection
 * @param props.body Search parameters for querying posts including text term,
 *   sort type, and pagination controls.
 * @path /communityPlatform/search/posts
 * @accessor api.functional.communityPlatform.search.posts.search
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function search(
  connection: IConnection,
  props: search.Props,
): Promise<search.Response> {
  return true === connection.simulate
    ? search.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...search.METADATA,
          path: search.path(),
          status: null,
        },
        props.body,
      );
}
export namespace search {
  export type Props = {
    /**
     * Search parameters for querying posts including text term, sort type,
     * and pagination controls.
     */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = IPageICommunityPlatformPost;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/search/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/search/posts";
  export const random = (): IPageICommunityPlatformPost =>
    typia.random<IPageICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: search.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: search.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve a specific post's full details by its unique ID.
 *
 * This operation provides the detailed content for a single post identified by
 * its unique postId parameter. The post details are retrieved from the
 * community_platform_posts table, which stores the complete text, metadata, and
 * relationships for each post including the title, body, author_id,
 * community_id, author_display_name, and timestamps.
 *
 * The operation enforces that the post must be active (deleted_at IS NULL) to
 * be visible. If a post has been deleted (hard or soft), the API returns a 404
 * Not Found response, preventing users from viewing deleted content. The
 * returned post includes the full content fields, including any line breaks in
 * the body, as text-only format is required by business rules. The
 * author_display_name is returned directly from the table, with 'Anonymous'
 * used if the field is null.
 *
 * The operation requires the postId parameter to be a valid UUID that
 * corresponds to an existing post in the community_platform_posts table. The
 * prefix of the community name (the 'name' field from the
 * community_platform_communities table) is derived from the community_id
 * relationship, ensuring correct display of the community context in the URL
 * path.
 *
 * Authentication is not required to access this endpoint as reading posts is
 * open to everyone according to the requirements. However, the API still
 * validates the user session for potential feature toggles such as whether the
 * viewer is the post's author (which determines whether edit/delete buttons
 * should be shown in the UI). This authorization check is handled by the
 * frontend via the user's session token, not by API authorization roles. The
 * operation is stateless and does not consume or modify any system resources,
 * making it safe for public access.
 *
 * The response structure uses the ICommunityPlatformPost type to return the
 * complete post object with all fields as defined in the Prisma schema,
 * including relationships to the author and community as references for
 * frontend routing.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to retrieve. Must be a
 *   valid UUID corresponding to a record in the community_platform_posts
 *   table.
 * @path /communityPlatform/search/posts/:postId
 * @accessor api.functional.communityPlatform.search.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the post to retrieve. Must be a valid UUID
     * corresponding to a record in the community_platform_posts table.
     */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/search/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/search/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
