import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommentScore } from "../../../../../structures/ICommunityPlatformCommentScore";

/**
 * Retrieve the vote score for a specific comment.
 *
 * This endpoint returns the current vote score for a comment, calculated as the
 * difference between the total number of upvotes and downvotes. The score is
 * retrieved from the community_platform_comment_stats table, a denormalized
 * statistics table that is atomically updated on every vote action to ensure
 * high-performance reads during comment rendering.
 *
 * This operation is essential for displaying the relative popularity of
 * comments in threaded discussions on post detail pages and in search results.
 * Without this denormalized table, calculating scores would require JOINs and
 * COUNTs across the community_platform_comment_votes table, which would be too
 * slow for real-time thread rendering.
 *
 * The endpoint returns only the numeric score value, as this is the only
 * information required by the client for display purposes. No additional
 * metadata is included to minimize payload size and ensure fast rendering of
 * comment threads. The client uses this score to sort comments by popularity
 * and to display score indicators next to each comment.
 *
 * Note: As per business rules, users cannot vote on their own comments, and
 * this endpoint does not return user-specific vote stateâ€”it only returns the
 * aggregated score.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment whose score is being
 *   requested. This reference maps directly to the
 *   community_platform_comment_stats.community_platform_comment_id field.
 * @path /communityPlatform/analytics/comments/:commentId/score
 * @accessor api.functional.communityPlatform.analytics.comments.score.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * Unique identifier of the comment whose score is being requested. This
     * reference maps directly to the
     * community_platform_comment_stats.community_platform_comment_id
     * field.
     */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommentScore;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/analytics/comments/:commentId/score",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/analytics/comments/${encodeURIComponent(props.commentId ?? "null")}/score`;
  export const random = (): ICommunityPlatformCommentScore =>
    typia.random<ICommunityPlatformCommentScore>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
