import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformIPageICommunity } from "../../../../../structures/ICommunityPlatformIPageICommunity";
import { ICommunityPlatformUserCommunityRequest } from "../../../../../structures/ICommunityPlatformUserCommunityRequest";
import { IPageICommunityPlatformUserCommunity } from "../../../../../structures/IPageICommunityPlatformUserCommunity";

/**
 * Retrieve a user's recent communities they've joined, ordered by last
 * interaction.
 *
 * This operation returns a list of communities that the authenticated user has
 * joined and interacted with, specifically designed to populate the 'Recent
 * Communities' sidebar in the UI. The communities are retrieved based on the
 * user's membership records in the community_platform_user_communities table,
 * filtering out any records where deleted_at is not null (i.e., communities the
 * user has left). Results are ordered by the last_interaction_at timestamp in
 * descending order to prioritize the most recently active communities, ensuring
 * the UI displays the most relevant communities first.
 *
 * The operation is optimized for performance by referencing the existing
 * community_platform_user_communities table which tracks all user-community
 * interactions, including joins, posts, comments, and votes. This ensures
 * real-time accuracy of the 'Recent Communities' list without requiring
 * expensive joins with other tables. The system returns a maximum of 5
 * communities as specified in the business requirements, which is enforced at
 * the query level. Each returned community includes only essential summary
 * information (name, logo, member count) to minimize payload size and optimize
 * for sidebar rendering.
 *
 * Authentication is required via the userId path parameter, which must
 * correspond to a valid community_platform_member.id. The user ID is validated
 * against the session to ensure the user is authorized to access their own
 * data. If the user ID is invalid, a 404 response is returned. If the user has
 * no active communities, an empty array is returned, which is handled
 * gracefully by the UI to display a placeholder message suggesting
 * exploration.
 *
 * This operation does not require a request body as all parameters are provided
 * in the path. The user's session must be active, and if expired, the API will
 * return a 401 Unauthorized response, prompting the frontend to open the login
 * modal and then retry the request after successful re-authentication.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the user whose recent communities
 *   are being requested. This must correspond to a valid
 *   community_platform_member.id in the system.
 * @path /communityPlatform/member/users/:userId/communities
 * @accessor api.functional.communityPlatform.member.users.communities.getByUserid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getByUserid(
  connection: IConnection,
  props: getByUserid.Props,
): Promise<getByUserid.Response> {
  return true === connection.simulate
    ? getByUserid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByUserid.METADATA,
          path: getByUserid.path(props),
          status: null,
        },
      );
}
export namespace getByUserid {
  export type Props = {
    /**
     * Unique identifier of the user whose recent communities are being
     * requested. This must correspond to a valid
     * community_platform_member.id in the system.
     */
    userId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformIPageICommunity.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/member/users/:userId/communities",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/users/${encodeURIComponent(props.userId ?? "null")}/communities`;
  export const random = (): ICommunityPlatformIPageICommunity.ISummary =>
    typia.random<ICommunityPlatformIPageICommunity.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: getByUserid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByUserid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve member's joined communities with filtering.
 *
 * This operation queries all community memberships for a specific member,
 * returning only those communities with an active membership (deleted_at is
 * null). The results include the community ID, name, last interaction
 * timestamp, and metadata, enabling the 'Recent Communities' sidebar to be
 * populated correctly.
 *
 * The operation supports filtering by activity recency (using
 * last_interaction_at descending) and pagination to limit results to the top 5
 * communities as required in the business logic. The endpoint does not support
 * filtering by community category or search — only membership status and
 * recency are relevant.
 *
 * The request body can be used to specify pagination parameters (limit, offset)
 * and sorting direction (ascending/descending) for last_interaction_at to
 * support client-side display logic. The server ensures that only community
 * records where deleted_at = NULL are returned — inactive memberships are
 * excluded.
 *
 * This operation is essential for rendering the Home feed, which shows posts
 * only from communities in this list. It is also used to populate and maintain
 * the 'Recent Communities' sidebar in the left navigation. Community
 * memberships are managed exclusively via join/leave actions on the community
 * page; this endpoint has no operations for creating or updating membership —
 * those are handled via the community page's Join button.
 *
 * For performance, the operation leverages the existing index on
 * community_platform_user_communities on (community_platform_user_id,
 * last_interaction_at). Results are not cached aggressively to ensure real-time
 * accuracy when a user joins or leaves a community.
 *
 * @param props.connection
 * @param props.userId Unique identifier of the target member in UUID format.
 * @param props.body Filtering and pagination parameters for retrieving
 *   communities. Includes limit (default 5), offset, and sort direction for
 *   last_interaction_at. Used to implement pagination in the 'Recent
 *   Communities' sidebar.
 * @path /communityPlatform/member/users/:userId/communities
 * @accessor api.functional.communityPlatform.member.users.communities.patchByUserid
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function patchByUserid(
  connection: IConnection,
  props: patchByUserid.Props,
): Promise<patchByUserid.Response> {
  return true === connection.simulate
    ? patchByUserid.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...patchByUserid.METADATA,
          path: patchByUserid.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace patchByUserid {
  export type Props = {
    /** Unique identifier of the target member in UUID format. */
    userId: string & tags.Format<"uuid">;

    /**
     * Filtering and pagination parameters for retrieving communities.
     * Includes limit (default 5), offset, and sort direction for
     * last_interaction_at. Used to implement pagination in the 'Recent
     * Communities' sidebar.
     */
    body: ICommunityPlatformUserCommunityRequest;
  };
  export type Body = ICommunityPlatformUserCommunityRequest;
  export type Response = IPageICommunityPlatformUserCommunity;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/users/:userId/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/users/${encodeURIComponent(props.userId ?? "null")}/communities`;
  export const random = (): IPageICommunityPlatformUserCommunity =>
    typia.random<IPageICommunityPlatformUserCommunity>();
  export const simulate = (
    connection: IConnection,
    props: patchByUserid.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: patchByUserid.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("userId")(() => typia.assert(props.userId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
