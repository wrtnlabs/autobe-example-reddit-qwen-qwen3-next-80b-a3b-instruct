import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../../structures/ICommunityPlatformPost";

/**
 * Set or toggle a user's vote state on a specific post.
 *
 * Creates or updates a user's vote state for a specific post. It interacts with
 * the community_platform_post_votes table and handles the business logic of
 * vote state transitions according to the required model: None → Upvote →
 * Downvote → None. If the user already has a vote on this post, the operation
 * toggles the state. The transaction is implemented with optimistic UI updates,
 * where the interface immediately reflects the new state before server
 * confirmation. This single endpoint handles all possible state changes,
 * avoiding redundancy and complexity. The operation is designed to be
 * idempotent, allowing users to rapidly toggle between vote states without race
 * conditions.
 *
 * The operation targets the community_platform_post_votes table as defined in
 * the Prisma schema, which enforces a unique constraint on the combination of
 * community_platform_post_id and community_platform_user_id to ensure each user
 * can have only one vote per post. This table contains fields for id,
 * community_platform_post_id, community_platform_user_id, created_at,
 * updated_at, and vote_state. The unique constraint automatically handles the
 * complexity of toggling between vote states as the application logic must
 * first determine the existing state and then either update or create a new
 * record accordingly.
 *
 * Security considerations include strict ownership validation to prevent users
 * from voting on their own content. The system checks the author_id of the post
 * against the authenticated user's ID (contained in the JWT) before allowing
 * any vote. If a user attempts to vote on their own post, the operation will
 * fail with a 403 response, and the display will show 'You can't vote on your
 * own posts/comments.' as specified in the business requirements. This
 * protection is enforced at both the API level and database level through this
 * operational check.
 *
 * This operation supports the core functionality of the post voting system,
 * where users can upvote or downvote content to influence its visibility in the
 * "Top" sort order. The vote state transitions follow these rules exactly:
 *
 * 1. None → Upvote (when Upvote button clicked and no previous vote)
 * 2. None → Downvote (when Downvote button clicked and no previous vote)
 * 3. Upvote → None (when Upvote button clicked again)
 * 4. Downvote → None (when Downvote button clicked again)
 * 5. Upvote → Downvote (when Downvote button clicked while upvoted)
 * 6. Downvote → Upvote (when Upvote button clicked while downvoted)
 *
 * This operation is directly linked to the community_platform_post_votes table
 * and related tables like community_platform_post_stats, which maintains a
 * denormalized count of the overall post score. When a vote is created or
 * updated, this statistic is updated atomically to ensure high-performance
 * sorting in the "Top" feed without requiring real-time joins or aggregations.
 *
 * Related API operations include the entertainment of vote state through the
 * optimistic UI without requiring retrieval, as the UI state is authoritative
 * and should mirror user action. POST /votes is the only permitted interaction
 * for vote state change. No retrieval or deletion endpoints are needed.
 *
 * The response returns no body, as the optimistic UI update will display the
 * new score immediately.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to vote on
 * @param props.body Details for the vote action to perform. Should include the
 *   desired vote state: 'upvote' or 'downvote'. The system will determine
 *   whether to create a new vote record or update the existing one based on the
 *   current state and the requested state. This follows the business rule that
 *   users can toggle between states but cannot vote when not authenticated or
 *   when voting on their own post.
 * @path /communityPlatform/member/posts/:postId/votes
 * @accessor api.functional.communityPlatform.member.posts.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<void> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the post to vote on */
    postId: string & tags.Format<"uuid">;

    /**
     * Details for the vote action to perform. Should include the desired
     * vote state: 'upvote' or 'downvote'. The system will determine whether
     * to create a new vote record or update the existing one based on the
     * current state and the requested state. This follows the business rule
     * that users can toggle between states but cannot vote when not
     * authenticated or when voting on their own post.
     */
    body: ICommunityPlatformPost.ICreateVote;
  };
  export type Body = ICommunityPlatformPost.ICreateVote;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/posts/:postId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the current vote state for a post.
 *
 * This operation retrieves the current vote state for a post by executing a
 * search on the community_platform_post_votes table. It requires the user to
 * send a PATCH request with a requestBody containing submission parameters that
 * identify the post ID and optionally, filtering criteria such as user
 * identification. The operation returns the user's current voting state
 * (upvote, downvote, or none) in the response body. This rather than GET, as it
 * handles complex state retrieval with dynamic parameters. This operation
 * demonstrates that collection searches with dynamic parameters must use PATCH
 * method rather than GET, even when no data modification occurs.
 *
 * The operation targets the community_platform_post_votes table as defined in
 * the Prisma schema, which contains the user's vote state (upvote or downvote)
 * for each post. Since the voting system does not store a 'none' state
 * explicitly (absence of record implies 'none'), this endpoint must determine
 * whether the current user has voted on the specific post by checking for the
 * existence of a record where community_platform_post_id matches the postId and
 * community_platform_user_id matches the authenticated user's ID.
 *
 * Security considerations include ensuring that only authenticated users can
 * check their own vote state. Unauthorized users cannot query vote states of
 * other users. The system verifies the user's authentication token before
 * executing the search. This follows the business rule that users can only
 * access their own voting data.
 *
 * This operation is directly linked to the community_platform_post_votes table
 * as defined in the Prisma schema, which includes fields for id,
 * community_platform_post_id, community_platform_user_id, created_at,
 * updated_at, and vote_state. The operation searches for records matching the
 * post ID and the authenticated user ID. If a record is found, the vote_state
 * field indicates the current state; if no record exists, the response
 * indicates 'none'.
 *
 * This operation supports pagination and search parameters to handle complex
 * filtering scenarios, though for this use case, the primary parameter is the
 * post identification. The response body structure is defined to return the
 * user's vote state for this specific post. This differs from the POST method
 * on the same endpoint, which is used to create or update votes, whereas this
 * PATCH method is solely for querying state.
 *
 * Related API operations include POST /posts/{postId}/votes to cast a vote and
 * DELETE /posts/{postId}/votes to remove a vote. This operation is critical for
 * implementing the optimistic UI update pattern, where the UI must know the
 * current vote state before allowing a user to toggle their vote. The
 * functionality enables a seamless user experience where clicking a vote button
 * shows the correct current state immediately without needing to refresh the
 * page.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post for which to retrieve the
 *   vote state
 * @param props.body Optional parameters for filtering the vote state result.
 *   The only required parameter is the user authentication context, which is
 *   provided through the API token. Additional parameters could include
 *   pagination or search filters if the system were designed to return multiple
 *   vote states, but in this implementation, the vote state is specifically for
 *   one post and one user.
 * @path /communityPlatform/member/posts/:postId/votes
 * @accessor api.functional.communityPlatform.member.posts.votes.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the post for which to retrieve the vote state */
    postId: string & tags.Format<"uuid">;

    /**
     * Optional parameters for filtering the vote state result. The only
     * required parameter is the user authentication context, which is
     * provided through the API token. Additional parameters could include
     * pagination or search filters if the system were designed to return
     * multiple vote states, but in this implementation, the vote state is
     * specifically for one post and one user.
     */
    body: ICommunityPlatformPost.IRequest;
  };
  export type Body = ICommunityPlatformPost.IRequest;
  export type Response = ICommunityPlatformPost.IVoteState;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/posts/:postId/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes`;
  export const random = (): ICommunityPlatformPost.IVoteState =>
    typia.random<ICommunityPlatformPost.IVoteState>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a user's vote on a specific post.
 *
 * This operation removes a user's vote on a specific post by deleting the
 * corresponding record from the community_platform_post_votes table. Unlike
 * toggling votes with POST, this operation explicitly removes the user's vote
 * state, setting it to 'none' without requiring a new vote action. It targets
 * the same table as other vote operations but is designed specifically for vote
 * clearance, supporting the behavior where users can click a button to remove
 * their vote entirely.
 *
 * The operation targets the community_platform_post_votes table as defined in
 * the Prisma schema, which tracks individual upvotes and downvotes with a
 * unique constraint ensuring one vote per user per post. When this delete
 * operation is executed, the system removes the record where
 * community_platform_post_id matches the postId and community_platform_user_id
 * matches the authenticated user's ID. If no such record exists, the operation
 * succeeds as a no-op, since 'none' is the implicit state.
 *
 * Security considerations include ensuring that only the authenticated user can
 * remove their own vote. This is enforced by checking the authentication token
 * against the user ID stored in the vote record. Users cannot remove votes from
 * other users' posts or from posts they haven't voted on. This follows the
 * business rule that users can only manipulate their own voting state.
 *
 * This operation complements the POST voting creation/update endpoint by
 * providing a more explicit and direct method to clear a vote. While the POST
 * method can achieve vote removal by toggling from an existing state, this
 * DELETE endpoint offers a cleaner semantic for users who specifically want to
 * remove their vote without changing it to the alternative state. The system
 * will update the denormalized community_platform_post_stats table atomically
 * to reflect the removal of the vote and recalculate the post's score (upvotes
 * - downvotes).
 *
 * This operation is linked directly to the community_platform_post_votes table
 * and is part of a complete vote lifecycle management system that includes POST
 * (create/update), PATCH (retrieve), and DELETE (remove). The delete operation
 * supports the requirement that users can toggle their vote state, but in this
 * case, the transition is from Upvote/Downvote → None, bypassing the
 * alternative state. This operation is used by the UI when a user clicks 'Undo
 * Vote' or when default behavior is to remove rather than toggle.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post from which to remove the
 *   user's vote
 * @path /communityPlatform/member/posts/:postId/votes
 * @accessor api.functional.communityPlatform.member.posts.votes.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post from which to remove the user's vote */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/posts/:postId/votes",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/votes`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
