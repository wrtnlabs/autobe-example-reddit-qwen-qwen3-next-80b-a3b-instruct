import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as comments from "./comments/index";
export * as votes from "./votes/index";

/**
 * Create a new post.
 *
 * This operation creates a new community post on the platform. The client
 * provides a JSON payload containing the community ID, post title, body
 * content, and optional author display name. The title must be between 5 and
 * 120 characters, and the body must be between 10 and 10,000 characters,
 * containing only plain text. The system requires the user to be logged in as a
 * member; unauthenticated requests receive a 401 Unauthorized response.
 *
 * The operation references the community_platform_posts table in the Prisma
 * schema, where the post is persisted with the provided title, body, author_id
 * (linked to the authenticated member), and creation timestamp. The
 * author_display_name is stored as provided or set to null if omitted, with
 * 'Anonymous' displayed in UI as fallback. The system strips any HTML, scripts,
 * or executable content and only preserves plain text with line breaks.
 *
 * Validation occurs both on the client and server. Server-side validation
 * ensures the target community exists, the title and body meet length
 * constraints, and the user has permission to post in that community (no
 * explicit permission check is needed beyond being authenticated). If
 * validation fails, the system returns a 400 Bad Request with a specific
 * message for each error (e.g., 'Title must be at least 5 characters' or 'Post
 * content cannot exceed 10,000 characters').
 *
 * Upon successful creation, the system returns a 201 Created status with the
 * full post object in the response body, including the generated unique ID. The
 * response triggers immediate UI updates: the post appears in the community's
 * feed and is added to the Global Latest sidebar. The post's author_id is
 * matched against the authenticated user's ID, enforcing content ownership
 * rules that allow only the author to edit or delete the post later.
 *
 * @param props.connection
 * @param props.body Data required to create a new post, including community,
 *   title, body, and optional display name
 * @path /communityPlatform/member/posts
 * @accessor api.functional.communityPlatform.member.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data required to create a new post, including community, title, body,
     * and optional display name
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post.
 *
 * This operation allows the authenticated author of a post to update its title
 * and content. The request must include the post ID in the path and a JSON body
 * with the new title (5-120 characters) and body (10-10,000 characters). The
 * update must be made by the original author of the post; attempts by other
 * users result in a 403 Forbidden response.
 *
 * The operation references the community_platform_posts table in the Prisma
 * schema, where only the title, body, and updated_at fields are modified. The
 * created_at field remains unchanged as per the requirement that post creation
 * times are immutable. The author_display_name field is not updated via this
 * operation; if the user wishes to change their display name, they must use the
 * profile settings, and the change will automatically reflect on future post
 * displays.
 *
 * Server-side validation checks the author's ownership against the
 * authenticated user's ID by comparing against the author_id field in the post
 * record. It also validates the five-and-one-hundred-twenty character limit for
 * title and one-thousand-to-ten-thousand character limit for body, ensuring
 * compliance with business rules before update. If a post has been soft-deleted
 * (deleted_at is not null), the update is denied with a 404 response.
 *
 * On successful update, the operation returns a 200 OK status with the updated
 * post object. The system uses optimistic UI updates: the post in the user's
 * feed displays the changes immediately before the server confirms. If the
 * server update fails, the UI rolls back to the original content and displays
 * an error: 'A temporary error occurred. Please try again in a moment.'
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be updated
 * @param props.body Updated data for the post including new title and body
 *   content
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the post to be updated */
    postId: string & tags.Format<"uuid">;

    /** Updated data for the post including new title and body content */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a post permanently.
 *
 * This operation permanently deletes a post from the platform. The user must be
 * either the original author of the post or an administrator to perform the
 * deletion. The request requires the post ID in the path and no request body.
 *
 * Per the Prisma schema, the community_platform_posts table does not contain a
 * soft-deletion column (like deleted_at) that would indicate soft-delete
 * functionality is implemented. Instead, the system performs a hard delete,
 * meaning the post record and all associated data (including comments, votes,
 * and search entries) are removed from the database immediately and cannot be
 * restored. This is not a soft delete but a permanent removal.
 *
 * The operation validates that the requesting user either matches the postâ€™s
 * author_id or holds admin privileges. If neither condition is met, a 403
 * Forbidden response is returned. If the post does not exist, a 404 Not Found
 * error is returned. The system must ensure that when a post is deleted, all
 * related records in community_platform_comments,
 * community_platform_post_votes, and community_platform_search_posts are also
 * removed via cascading deletions in the database schemas.
 *
 * After successful deletion, the system returns a 204 No Content response. The
 * UI updates optimistically by removing the post from the feed immediately,
 * with server replication confirming the removal. If deletion fails on the
 * server side, the UI restores the post and displays: 'A temporary error
 * occurred. Please try again in a moment.'
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post to be deleted
 * @path /communityPlatform/member/posts/:postId
 * @accessor api.functional.communityPlatform.member.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post to be deleted */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
