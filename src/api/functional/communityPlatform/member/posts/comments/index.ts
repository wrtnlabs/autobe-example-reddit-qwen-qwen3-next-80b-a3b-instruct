import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../../../structures/ICommunityPlatformComment";

/**
 * Create a new comment on a post.
 *
 * Create a new comment on a specified post. The comment can be a top-level
 * comment or a reply to an existing comment. The request body must include the
 * content (2-2,000 characters), and optionally the parent_id for nested
 * replies.
 *
 * The system validates that the user is authenticated (member role) and that
 * the comment content meets length requirements (2-2,000 characters). It also
 * validates that the user is not trying to create a comment on a post that has
 * been soft-deleted.
 *
 * After successful creation, the operation updates the parent post's comment
 * count in the community_platform_post_stats table and adds the comment to the
 * community_platform_search_comments materialized view. For nested replies, it
 * increments the reply count on the parent comment using the
 * community_platform_comment_stats table.
 *
 * The response returns the full created comment object, including the generated
 * ID, timestamps, and calculated score, allowing the client to update the UI
 * optimistically.
 *
 * This endpoint is accessed when users submit comments on post detail pages and
 * when replying to existing comments within threads.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post
 * @param props.body Content and parent reference for new comment creation
 * @path /communityPlatform/member/posts/:postId/comments
 * @accessor api.functional.communityPlatform.member.posts.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target post */
    postId: string & tags.Format<"uuid">;

    /** Content and parent reference for new comment creation */
    body: ICommunityPlatformComment.ICreate;
  };
  export type Body = ICommunityPlatformComment.ICreate;
  export type Response = ICommunityPlatformComment.ISparse;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): ICommunityPlatformComment.ISparse =>
    typia.random<ICommunityPlatformComment.ISparse>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing comment.
 *
 * Update the content of an existing comment. This operation is only permitted
 * if the authenticated user is the original author of the comment. The request
 * body must contain the new content, which must be between 2 and 2,000
 * characters.
 *
 * The server validates comment ownership by verifying the user's ID matches the
 * comment's author_id. It also checks that the comment has not been
 * soft-deleted (deleted_at is null) and validates the new content length
 * constraints.
 *
 * Upon successful update, the operation sets the updated_at timestamp to the
 * current time and updates the community_platform_search_comments materialized
 * view with the new content. The comment's score and reply count remain
 * unchanged.
 *
 * This endpoint supports optimized frontend updates: the frontend applies
 * changes immediately (optimistic update) and only reverts if the server
 * returns an error, with a "A temporary error occurred. Please try again in a
 * moment." message.
 *
 * This operation is used exclusively by comment authors to correct typos,
 * update information, or improve clarity after initial submission.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post containing the comment
 * @param props.commentId Unique identifier of the target comment
 * @param props.body New content for the comment (2-2,000 characters)
 * @path /communityPlatform/member/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPlatform.member.posts.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the post containing the comment */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target comment */
    commentId: string & tags.Format<"uuid">;

    /** New content for the comment (2-2,000 characters) */
    body: ICommunityPlatformComment.IUpdate;
  };
  export type Body = ICommunityPlatformComment.IUpdate;
  export type Response = ICommunityPlatformComment.ISparse;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/posts/:postId/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPlatformComment.ISparse =>
    typia.random<ICommunityPlatformComment.ISparse>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a specific comment.
 *
 * This operation soft deletes a specific comment by setting the deleted_at
 * timestamp to the current time. The comment record is preserved for audit
 * purposes but excluded from normal queries. This operation targets the
 * community_platform_comments table, removing the comment from all user-facing
 * views while maintaining a complete audit trail of user interactions. This is
 * a soft delete operation since the Prisma schema includes a deleted_at field
 * for comments. The deletion cascades to remove the comment from all related
 * views and search indexes, but the record remains persistent for compliance
 * purposes.
 *
 * Security considerations include strict ownership validation: only the
 * authenticated user who created the comment or an admin can execute this
 * operation. The system verifies the comment's author_id matches the
 * authenticated user's ID before proceeding with deletion. This ensures
 * compliance with the business rule that users can only delete their own
 * content. Admins are granted override capabilities through role-based
 * authorization.
 *
 * This operation is directly linked to the community_platform_comments table as
 * defined in the Prisma schema, which includes fields for id, post_id,
 * author_id, parent_id, content, created_at, updated_at, and deleted_at. The
 * deletion marks the record with the current timestamp, and any associated
 * records in community_platform_comment_votes and
 * community_platform_comment_stats are logically removed by filter-based
 * queries, not physical deletion. The record remains in the database but is
 * excluded from all endpoints exposed to users.
 *
 * This operation should not be confused with hard delete behaviors. Since the
 * comment table supports soft delete via the deleted_at column (unlike other
 * tables where such columns are absent), this represents a soft delete pattern
 * that maintains data integrity and audit compliance. The presence of the
 * deleted_at field in the schema requires this behavior, and attempts to
 * implement hard delete would violate the system's data retention policies.
 *
 * Related API operations include PATCH /posts/{postId}/comments to retrieve
 * comment threads and POST /posts/{postId}/comments to create new comments.
 * This delete operation should be preceded by a check to verify the user owns
 * the comment or has appropriate privileges, and should be confirmed by the
 * user to prevent accidental deletion. After deletion, this comment will no
 * longer appear in any feed, search results, or thread hierarchy.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post containing the comment to
 *   be deleted
 * @param props.commentId Unique identifier of the specific comment to be
 *   deleted
 * @path /communityPlatform/member/posts/:postId/comments/:commentId
 * @accessor api.functional.communityPlatform.member.posts.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post containing the comment to be deleted */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the specific comment to be deleted */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
