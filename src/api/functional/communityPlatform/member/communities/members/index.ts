import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityPlatformUserCommunity } from "../../../../../structures/ICommunityPlatformCommunityPlatformUserCommunity";

/**
 * Join a specific community and create membership record.
 *
 * Establish a new membership relationship between an authenticated user and a
 * specified community. This operation creates a record in the
 * community_platform_user_communities table with the joining user's ID and the
 * target community's ID, along with timestamps for creation and the immediate
 * last interaction.
 *
 * The system enforces several validation rules: the community must exist and
 * have not been deleted; the user must be authenticated; the user must not have
 * an active membership (deleted_at is null) in the community already; the
 * community name must be in the correct alphanumeric format. When these
 * conditions are satisfied, the system immediately updates the member_count in
 * the community_platform_communities table and in the
 * community_platform_community_stats denormalized table.
 *
 * Security considerations include ensuring that only authenticated users can
 * join communities and that users cannot join their own communities if they're
 * not the creator (which is a separate constraint). This operation updates the
 * 'Recent Communities' list in the user's left sidebar with the newly joined
 * community, sorted by the last_interaction_at timestamp.
 *
 * This operation integrates with the community_platform_user_communities table
 * as defined in the Prisma schema, incorporating the user_id, community_id, and
 * interaction timestamps. The response includes the validated membership record
 * in a successful response, with appropriate error handling for invalid
 * requests.
 *
 * @param props.connection
 * @param props.communityName Unique alphanumeric identifier of the target
 *   community to join. Must be 5 to 64 characters and may contain hyphens (-)
 *   and underscores (_). This corresponds to the name field in the
 *   community_platform_communities table.
 * @path /communityPlatform/member/communities/:communityName/members
 * @accessor api.functional.communityPlatform.member.communities.members.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
      );
}
export namespace create {
  export type Props = {
    /**
     * Unique alphanumeric identifier of the target community to join. Must
     * be 5 to 64 characters and may contain hyphens (-) and underscores
     * (_). This corresponds to the name field in the
     * community_platform_communities table.
     */
    communityName: string;
  };
  export type Response = ICommunityPlatformCommunityPlatformUserCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/communities/:communityName/members",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityName ?? "null")}/members`;
  export const random = (): ICommunityPlatformCommunityPlatformUserCommunity =>
    typia.random<ICommunityPlatformCommunityPlatformUserCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Leave a specific community and deactivate membership.
 *
 * Deactivate a user's membership in a specific community by setting the
 * deleted_at timestamp in the community_platform_user_communities table. This
 * soft-delete pattern preserves audit history while removing the user's view of
 * the community's content from their Home feed.
 *
 * The system enforces several validation rules: the community must exist; the
 * user must be authenticated and have a current active membership (deleted_at
 * is null); the user must not be the community creator if the center has
 * restrictions (though this is handled by business logic). When successful, the
 * operation decrements the member_count in both the
 * community_platform_communities table and the
 * community_platform_community_stats denormalized table.
 *
 * Security considerations include ensuring that only the owning user or an
 * admin can leave a community. Other users attempting to leave a community
 * they're not a member of will receive a 404 Not Found response. This operation
 * updates the 'Recent Communities' list in the user's left sidebar by removing
 * the community if it was among the 5 most recently active.
 *
 * This operation integrates with the community_platform_user_communities table
 * as defined in the Prisma schema, maintaining the original record with the new
 * deleted_at timestamp. The response is a 204 No Content upon success, or
 * appropriate error responses for failures.
 *
 * @param props.connection
 * @param props.communityName Unique alphanumeric identifier of the target
 *   community to leave. Must be 5 to 64 characters and may contain hyphens (-)
 *   and underscores (_). This corresponds to the name field in the
 *   community_platform_communities table.
 * @path /communityPlatform/member/communities/:communityName/members
 * @accessor api.functional.communityPlatform.member.communities.members.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique alphanumeric identifier of the target community to leave. Must
     * be 5 to 64 characters and may contain hyphens (-) and underscores
     * (_). This corresponds to the name field in the
     * community_platform_communities table.
     */
    communityName: string;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/communities/:communityName/members",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityName ?? "null")}/members`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
