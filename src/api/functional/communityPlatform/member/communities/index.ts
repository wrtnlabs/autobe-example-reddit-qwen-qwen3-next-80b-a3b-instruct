import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunity } from "../../../../structures/ICommunityPlatformCommunity";
export * as members from "./members/index";

/**
 * Create a new community with specified metadata.
 *
 * This operation allows an authenticated member to create a new sub-community
 * with a unique name, category, and optional metadata including description,
 * rules, logo, and banner. The system validates the community name against
 * format constraints: it must be 5-64 characters long, contain only
 * alphanumeric characters, hyphens (-), and underscores (_), and must be
 * globally unique across the entire platform.
 *
 * Security considerations require the user to be authenticated with a valid
 * member role. Guest users are blocked from this operation, and the system will
 * return a 401 Unauthorized response. The operation enforces ownership by
 * automatically linking the creator's member ID to the new community. Attempts
 * to create a community with an existing name will return a 409 Conflict error
 * with the message "This name is already in use.".
 *
 * The community structure is based on the community_platform_communities table
 * in the Prisma schema, with all fields (name, category, description, rules,
 * logo_url, banner_url) being persisted as defined. The system automatically
 * initializes member_count to 1 (the creator) and sets the created_at
 * timestamp. Upon successful creation, the system generates a
 * community_platform_search_communities record for full-text search indexing.
 *
 * The user is automatically granted membership to the new community by creating
 * a record in the community_platform_user_communities table with created_at and
 * last_interaction_at set to the current timestamp and deleted_at set to null.
 * This ensures the new community immediately appears in the user's "Recent
 * Communities" list and participates in their Home feed.
 *
 * The operation ignores any values submitted for system-managed fields such as
 * id, created_at, updated_at, and member_count since these are handled
 * internally by the system.
 *
 * @param props.connection
 * @param props.body Request payload containing the new community's metadata
 *   including name, category, description, rules, logo, and banner URL
 * @path /communityPlatform/member/communities
 * @accessor api.functional.communityPlatform.member.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Request payload containing the new community's metadata including
     * name, category, description, rules, logo, and banner URL
     */
    body: ICommunityPlatformCommunity.ICreate;
  };
  export type Body = ICommunityPlatformCommunity.ICreate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/member/communities";
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update editable metadata of a community (description, rules, logo, banner).
 *
 * This operation allows the creator of a specific community to update its
 * editable metadata fields: description, rules, logo_url, and banner_url. Only
 * the original creator (the member who created the community) is permitted to
 * make these changes - other members or admins cannot modify community metadata
 * unless granted special administrative permissions (which are not implemented
 * in this system).
 *
 * The operation requires a valid authentication token belonging to the
 * community creator. If the requesting member is not the original creator, the
 * system returns a 403 Forbidden response with the message "You can only edit
 * communities you created.". The community name cannot be modified and any
 * attempt to include it in the request body will be ignored.
 *
 * The update triggers a refresh of the community_platform_search_communities
 * materialized view to ensure full-text search functionality remains current.
 * The system allows partial updates - if a field is omitted from the request
 * body, its value remains unchanged.
 *
 * The description field can be updated to up to 500 characters, rules can be
 * updated to up to 20 lines (with only the first 5 being displayed in UI), and
 * logo and banner URLs can be updated to new image paths. The system validates
 * file extensions and URL lengths but does not validate image content or
 * existence on the client side.
 *
 * By design, only the creator can make these changes to ensure stability and
 * prevent community hijacking. Admins do not have override permissions for this
 * operation to maintain clear ownership boundaries.
 *
 * @param props.connection
 * @param props.communityName Unique alphanumeric identifier of the target
 *   community to be updated
 * @param props.body Partial update payload containing optional fields:
 *   description, rules, logo_url, and/or banner_url
 * @path /communityPlatform/member/communities/:communityName
 * @accessor api.functional.communityPlatform.member.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique alphanumeric identifier of the target community to be updated */
    communityName: string &
      tags.MinLength<5> &
      tags.MaxLength<64> &
      tags.Pattern<"^[a-zA-Z0-9_-]+$">;

    /**
     * Partial update payload containing optional fields: description,
     * rules, logo_url, and/or banner_url
     */
    body: ICommunityPlatformCommunity.IUpdate;
  };
  export type Body = ICommunityPlatformCommunity.IUpdate;
  export type Response = ICommunityPlatformCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/communities/:communityName",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityName ?? "null")}`;
  export const random = (): ICommunityPlatformCommunity =>
    typia.random<ICommunityPlatformCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a community and all its content.
 *
 * This operation permanently deletes a community and all its associated data,
 * including all posts, comments, votes, and search indexes associated with the
 * community. This is a hard delete operation with no soft delete mechanism, as
 * the system relies on the community_platform_communities table without a
 * deleted_at column.
 *
 * Only the original creator of the community or an admin can execute this
 * operation. The system checks the requesting member's role against
 * community_architect permissions. If the requesting user is neither the
 * creator nor an admin, a 403 Forbidden response is returned with the message
 * "You can only delete communities you created.".
 *
 * The deletion is cascaded through the database: all community_platform_posts
 * entries linked to this community are deleted, followed by all associated
 * community_platform_comments, community_platform_post_votes, and
 * community_platform_comment_votes. The community_platform_search_communities,
 * community_platform_search_posts, and community_platform_search_comments
 * materialized views are automatically refreshed by system triggers.
 *
 * The relationship records in community_platform_user_communities are also
 * deleted, which removes the community from all users' "Recent Communities"
 * lists. The community_platform_community_stats record is removed, and
 * membership counts for all other communities remain unaffected.
 *
 * This is a destructive operation with no undo capability. The system should
 * confirm the action in the UI with "Are you sure you want to delete this
 * community? This cannot be undone." before sending the API request. After
 * successful deletion, a 204 No Content response is returned.
 *
 * @param props.connection
 * @param props.communityName Unique alphanumeric identifier of the community to
 *   be permanently deleted
 * @path /communityPlatform/member/communities/:communityName
 * @accessor api.functional.communityPlatform.member.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique alphanumeric identifier of the community to be permanently
     * deleted
     */
    communityName: string &
      tags.MinLength<5> &
      tags.MaxLength<64> &
      tags.Pattern<"^[a-zA-Z0-9_-]+$">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/communities/:communityName",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityName ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityName")(() => typia.assert(props.communityName));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
