import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IVote } from "../../structures/IVote";

/**
 * Cast an upvote or downvote on a post or comment.
 *
 * This operation enables an authenticated member to vote on any post or
 * comment. The system creates an entry in the communitybbs_vote table by
 * setting the actor_id to the authenticated member's id, and either post_id or
 * comment_id to the target object's id, while ensuring exactly one target is
 * provided (mutually exclusive). The type field is set to either 'upvote' or
 * 'downvote'. The system enforces a constraint that no member can vote more
 * than once on the same post or comment by checking the unique index on
 * [actor_id, post_id] and [actor_id, comment_id]. If a user attempts to change
 * their vote (e.g., from upvote to downvote), the system deletes their existing
 * vote record and creates a new one with the updated type. If the user attempts
 * to vote on their own content, the system prevents the action by checking the
 * author_id fields of the target post or comment and returns an error message
 * as required by business rules. This implementation aligns with the
 * communitybbs_vote tableâ€™s design, which stores vote type and reference to the
 * actor and target. Votes are used to compute the score fields in
 * communitybbs_post and communitybbs_comment tables via postgresql aggregate
 * views or application logic.
 *
 * @param props.connection
 * @param props.body Request body specifying vote type ('upvote' or 'downvote')
 *   and target (either post_id or comment_id).
 * @path /votes
 * @accessor api.functional.votes.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Request body specifying vote type ('upvote' or 'downvote') and target
     * (either post_id or comment_id).
     */
    body: IVote.ICreate;
  };
  export type Body = IVote.ICreate;
  export type Response = IVote;

  export const METADATA = {
    method: "POST",
    path: "/votes",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/votes";
  export const random = (): IVote => typia.random<IVote>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
