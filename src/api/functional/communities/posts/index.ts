import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsPost } from "../../../structures/ICommunitybbsPost";
import { IPageICommunitybbsPost } from "../../../structures/IPageICommunitybbsPost";
export * as comments from "./comments/index";
export * as votes from "./votes/index";

/**
 * Create a new post in a specified community.
 *
 * Create a new post in the specified community. This operation requires the
 * user to be authenticated as a member and to submit a valid title and body.
 * The title must be between 5 and 120 characters and the body between 10 and
 * 10,000 characters, as per requirements. The body content must be plain text
 * only, with no HTML, scripts, or code allowed — any attempt to include these
 * will be rejected. The author's display name is captured at the time of
 * submission and stored as part of the post for consistency, even if the member
 * later changes their display name. If no display name is provided, the system
 * defaults to 'Anonymous'. The new post is associated with the given community
 * via the communityId path parameter and the authenticated member's ID. Upon
 * successful creation, the community's last_active_at timestamp is updated to
 * the current time, and the post count is incremented internally. The post is
 * immediately available in the community feed and is indexed in the search
 * system. This operation does not require soft delete handling during
 * submission because the post is created in active state only; soft deletion is
 * a permissioned moderation action handled separately. The post is created as a
 * direct user-initiated action, not a system-generated record, and must be
 * trackable to the user who submitted it. This endpoint is protected — guests
 * cannot create posts and will be redirected to login. Only the member role has
 * permission to invoke this endpoint.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to which the post
 *   will be added.
 * @param props.body Creation data for a new post, including title, body, and
 *   optional display name.
 * @path /communities/:communityId/posts
 * @accessor api.functional.communities.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the community to which the post will be added. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Creation data for a new post, including title, body, and optional
     * display name.
     */
    body: ICommunitybbsPost.ICreate;
  };
  export type Body = ICommunitybbsPost.ICreate;
  export type Response = ICommunitybbsPost.ISummary;

  export const METADATA = {
    method: "POST",
    path: "/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): ICommunitybbsPost.ISummary =>
    typia.random<ICommunitybbsPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve paginated posts from a specific community.
 *
 * Retrieve an ordered and paginated list of posts from a specific community,
 * filtered by the provided search criteria. This operation supports advanced
 * filtering using the request body, including sort order (Newest or Top),
 * limit, offset, and text search. For the 'Newest' sort order, results are
 * sorted by creation_time descending, and then by post_id descending for ties.
 * For the 'Top' sort order, results are sorted by score (upvotes minus
 * downvotes) descending, followed by creation_time descending, and finally by
 * post_id descending. The operation only returns posts where deleted_at is
 * null, ensuring archived posts are excluded. The results are constructed by
 * querying the communitybbs_post table, using the communitybbs_community_id as
 * the filter, and joined with the communitybbs_vote table to compute scores
 * using sum conditions. The communitybbs_search_post table is not used here
 * because this endpoint is community-specific and does not require full-text
 * search across the whole platform — instead, it performs standard database
 * queries optimized for range and index scans on the community-specific post
 * set. Pagination is implemented via offset and limit, fetching exactly 20
 * posts per page as per requirements. This endpoint must be accessible to all
 * authenticated users and reflects the user's joined community state — if the
 * user has not joined the community, the results are still accessible
 * (read-only), matching the public nature of community posts. No role
 * restrictions are needed because posts within communities are publicly
 * readable by design.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to retrieve posts
 *   from.
 * @param props.body Search criteria and pagination parameters for filtering
 *   posts within a community. Sort must be one of 'Newest' or 'Top'. Default
 *   page is 1, limit is 20. Supports full-text search on title and body.
 * @path /communities/:communityId/posts
 * @accessor api.functional.communities.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the community to retrieve posts from. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for filtering posts within
     * a community. Sort must be one of 'Newest' or 'Top'. Default page is
     * 1, limit is 20. Supports full-text search on title and body.
     */
    body: ICommunitybbsPost.IRequest;
  };
  export type Body = ICommunitybbsPost.IRequest;
  export type Response = IPageICommunitybbsPost;

  export const METADATA = {
    method: "PATCH",
    path: "/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): IPageICommunitybbsPost =>
    typia.random<IPageICommunitybbsPost>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the full details of a specific post.
 *
 * Retrieve the detailed information of a specific post, identified by its
 * unique post ID within the context of its community. This operation returns
 * the complete post object with all its fields: title, body, author display
 * name (as captured at time of creation), creation timestamp, update timestamp,
 * and score (calculated as upvotes minus downvotes). The system verifies that
 * the target post belongs to the specified community and that the post has not
 * been soft-deleted (deleted_at is null). This operation does not return
 * associated comments — those are available via a separate endpoint at
 * /communities/{communityId}/posts/{postId}/comments. This endpoint is designed
 * to support public viewability; any user — guest or authenticated — may access
 * a post detail page. The query joins the communitybbs_post table with the
 * communitybbs_community table to confirm relationship and with the
 * communitybbs_vote table to compute the score using sum conditions. No user
 * role restrictions are needed because access to post content is public by
 * design, as specified in the requirements. The response is optimized for
 * frontend rendering and includes all required metadata for rendering the post
 * detail page without requiring additional API calls. This endpoint must
 * maintain high performance because it is frequently accessed during user
 * navigation.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   post.
 * @param props.postId Unique identifier of the post to retrieve.
 * @path /communities/:communityId/posts/:postId
 * @accessor api.functional.communities.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the community containing the post. */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the post to retrieve. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunitybbsPost.ISummary;

  export const METADATA = {
    method: "GET",
    path: "/communities/:communityId/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunitybbsPost.ISummary =>
    typia.random<ICommunitybbsPost.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
