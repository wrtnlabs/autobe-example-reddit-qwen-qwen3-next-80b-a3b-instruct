import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsComment } from "../../../../structures/ICommunitybbsComment";

/**
 * Create a new comment on a specific post.
 *
 * This operation enables authenticated users to add comments to existing posts
 * within a community. The comment is stored in the communitybbs_comment table
 * and is associated with the specific post using the postId parameter and the
 * community through the communityId parameter.
 *
 * The comment content must adhere to the business rules defined in the schema:
 * minimum 2 characters and maximum 2,000 characters. The author of the comment
 * must be an authenticated member, and their display name may be provided, but
 * if included, it must not exceed 32 characters. If no display name is
 * provided, the system will use the authenticated member's display name from
 * their profile.
 *
 * Security considerations require that only authenticated members can create
 * comments; guest users are not permitted. This operation does not support
 * creating top-level comments on communities directly, only comments nested
 * under posts.
 *
 * The operation integrates with the communitybbs_comment entity and its
 * relationship to communitybbs_post, which has a foreign key relationship
 * established between post_id and id. This ensures referential integrity so
 * that comments cannot be created for non-existent posts.
 *
 * This operation triggers system-generated logging events as defined in the
 * communitybbs_log model, but there is no separate API to create or manage
 * these logs - they are created automatically as a side effect of this
 * operation. The comment's creation timestamp is automatically set by the
 * system and cannot be overridden by the client.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community where the
 *   post resides
 * @param props.postId Unique identifier of the target post to which the comment
 *   is being added
 * @param props.body Data required to create a new comment on a post
 * @path /communities/:communityId/posts/:postId/comments
 * @accessor api.functional.communities.posts.comments.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target community where the post resides */
    communityId: string & tags.Format<"uuid">;

    /**
     * Unique identifier of the target post to which the comment is being
     * added
     */
    postId: string & tags.Format<"uuid">;

    /** Data required to create a new comment on a post */
    body: ICommunitybbsComment.ICreate;
  };
  export type Body = ICommunitybbsComment.ICreate;
  export type Response = ICommunitybbsComment;

  export const METADATA = {
    method: "POST",
    path: "/communities/:communityId/posts/:postId/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments`;
  export const random = (): ICommunitybbsComment =>
    typia.random<ICommunitybbsComment>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing comment.
 *
 * This operation allows an authenticated user to modify the content of a
 * comment they previously authored on a post. The comment is located by its
 * unique commentId, and ownership is verified by comparing the authenticated
 * user's ID with the communitybbs_member_id field in the communitybbs_comment
 * table.
 *
 * The update request must provide new content for the comment that adheres to
 * the schema constraints: between 2 and 2,000 characters in length. The
 * display_name field may be updated if desired, but it must not exceed 32
 * characters. The communityId and postId parameters in the path are for context
 * and validation purposes but cannot be modified as they are fixed by the
 * original comment record.
 *
 * If the authenticated user is not the original author of the comment or an
 * administrator, the operation will be denied with a 403 error. This implements
 * the business logic rule that "You can edit or delete only items you
 * authored."
 *
 * This operation automatically updates the updated_at timestamp in the
 * communitybbs_comment table as defined in the Prisma schema, which is used to
 * reflect comment revisions and support ordering in UI displays. The system
 * also records an audit log entry in the communitybbs_log table as a side
 * effect, but there is no direct API to manipulate these logs.
 *
 * The comment's creation timestamp (created_at) remains immutable after comment
 * creation according to schema design principles, ensuring historical accuracy
 * and compliance with the requirements that specify no modification of creation
 * times.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community containing
 *   the post and comment
 * @param props.postId Unique identifier of the target post containing the
 *   comment
 * @param props.commentId Unique identifier of the target comment to be updated
 * @param props.body Updated content and optional display_name for the comment
 * @path /communities/:communityId/posts/:postId/comments/:commentId
 * @accessor api.functional.communities.posts.comments.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /**
     * Unique identifier of the target community containing the post and
     * comment
     */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the target post containing the comment */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target comment to be updated */
    commentId: string & tags.Format<"uuid">;

    /** Updated content and optional display_name for the comment */
    body: ICommunitybbsComment.IUpdate;
  };
  export type Body = ICommunitybbsComment.IUpdate;
  export type Response = ICommunitybbsComment;

  export const METADATA = {
    method: "PUT",
    path: "/communities/:communityId/posts/:postId/comments/:commentId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunitybbsComment =>
    typia.random<ICommunitybbsComment>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a comment.
 *
 * This operation marks a comment as deleted by setting the deleted_at timestamp
 * to the current time. The comment record is preserved in the database for
 * audit purposes but is excluded from normal queries and displays, as defined
 * by the communitybbs_comment model which includes a deleted_at field.
 *
 * The deletion is restricted to the comment's original author (authenticated
 * member) or an administrator with elevated privileges. Ownership verification
 * is performed by comparing the authenticated user's ID against the
 * communitybbs_member_id field in the communitybbs_comment table. The operation
 * will fail with a 403 error if the requester is not the author or an
 * administrator.
 *
 * This operation adheres strictly to the business rule: "You can edit or delete
 * only items you authored." unless the user has an administrator role.
 *
 * When a comment is soft-deleted, it remains in the database with its completed
 * data, and any nested replies are also marked as deleted via the foreign key
 * relationships. This preserves data integrity and enables potential recovery
 * while hiding the content from users.
 *
 * The system automatically logs this deletion event in the communitybbs_log
 * table as a side effect (action_type: 'comment_deleted'), but there is no
 * separate API endpoint to create or manage these logs.
 *
 * This soft delete is intentional and consistent with the design of the
 * communitybbs_comment entity, which includes a deleted_at field, and aligns
 * with the system's philosophy of preserving data for compliance and audit
 * purposes rather than permanent removal.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community containing
 *   the post and comment
 * @param props.postId Unique identifier of the target post containing the
 *   comment
 * @param props.commentId Unique identifier of the target comment to be
 *   soft-deleted
 * @path /communities/:communityId/posts/:postId/comments/:commentId
 * @accessor api.functional.communities.posts.comments.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /**
     * Unique identifier of the target community containing the post and
     * comment
     */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the target post containing the comment */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the target comment to be soft-deleted */
    commentId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communities/:communityId/posts/:postId/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
