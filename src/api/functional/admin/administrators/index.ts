import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsAdministrator } from "../../../structures/ICommunitybbsAdministrator";
import { IResponseEmpty } from "../../../structures/IResponseEmpty";

/**
 * Suspend administrator access by revoking all sessions (Admin only).
 *
 * This endpoint suspends an administrator’s access by invalidating their active
 * sessions and blocking future authentication.
 *
 * The system searches for all active sessions (where is_valid = true and
 * deleted_at is null) associated with the administrator’s email in the
 * communitybbs_session table. Each found session is updated: is_valid is set to
 * false, and deleted_at is set to the current timestamp. This immediately
 * terminates all active sessions without needing to revoke individual tokens.
 *
 * The administrator record in communitybbs_administrator remains intact,
 * preserving the user’s audit history, display_name, and email. This preserves
 * accountability and enables future reactivation if needed.
 *
 * A log entry is created in the communitybbs_log table with action_type
 * 'administrator_suspended', including the identity of the suspending
 * administrator and the target administrator.
 *
 * This operation does not delete the primary administrator record, so their
 * email cannot be reused until explicitly freed. This ensures the suspension is
 * reversible by resetting is_valid to true and generating new tokens. It is
 * equivalent to disabling an account in enterprise systems, rather than
 * deleting it.
 *
 * @param props.connection
 * @param props.email The email address of the administrator to suspend.
 * @path /admin/administrators/:email/suspend
 * @accessor api.functional.admin.administrators.suspend
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function suspend(
  connection: IConnection,
  props: suspend.Props,
): Promise<suspend.Response> {
  return true === connection.simulate
    ? suspend.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...suspend.METADATA,
          path: suspend.path(props),
          status: null,
        },
      );
}
export namespace suspend {
  export type Props = {
    /** The email address of the administrator to suspend. */
    email: string & tags.Format<"email">;
  };
  export type Response = ICommunitybbsAdministrator;

  export const METADATA = {
    method: "PUT",
    path: "/admin/administrators/:email/suspend",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/administrators/${encodeURIComponent(props.email ?? "null")}/suspend`;
  export const random = (): ICommunitybbsAdministrator =>
    typia.random<ICommunitybbsAdministrator>();
  export const simulate = (
    connection: IConnection,
    props: suspend.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: suspend.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore suspended administrator access (Admin only).
 *
 * This endpoint reactivates a previously suspended administrator account by
 * restoring valid sessions.
 *
 * The system locates all entries in the communitybbs_session table where: (1)
 * actor_id corresponds to the administrator with the provided email, and (2)
 * deleted_at is set (meaning they were suspended). For each such session,
 * is_valid is set to true and deleted_at is cleared (set to null).
 *
 * The administrator record in communitybbs_administrator is not modified. No
 * new credentials are issued; the administrator can log back in using their
 * existing password and email.
 *
 * A log entry is created in the communitybbs_log table with action_type
 * 'administrator_resumed', logging the administrator who performed the
 * restoration and the target administrator.
 *
 * This operation reverses the suspend operation and allows administrators to
 * regain access without needing to be recreated. It is the preferred method
 * over account deletion and recreation to preserve audit history and maintain
 * data integrity.
 *
 * @param props.connection
 * @param props.email The email address of the administrator to resume.
 * @path /admin/administrators/:email/resume
 * @accessor api.functional.admin.administrators.resume
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function resume(
  connection: IConnection,
  props: resume.Props,
): Promise<resume.Response> {
  return true === connection.simulate
    ? resume.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...resume.METADATA,
          path: resume.path(props),
          status: null,
        },
      );
}
export namespace resume {
  export type Props = {
    /** The email address of the administrator to resume. */
    email: string & tags.Format<"email">;
  };
  export type Response = ICommunitybbsAdministrator;

  export const METADATA = {
    method: "PUT",
    path: "/admin/administrators/:email/resume",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/administrators/${encodeURIComponent(props.email ?? "null")}/resume`;
  export const random = (): ICommunitybbsAdministrator =>
    typia.random<ICommunitybbsAdministrator>();
  export const simulate = (
    connection: IConnection,
    props: resume.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: resume.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete an administrator account (Admin only).
 *
 * This endpoint permanently deletes an administrator account from the system.
 *
 * The system first verifies that the administration request is authorized
 * through the authenticated administrator’s privileges, and requires
 * dual-authorization confirmation to prevent unauthorized deletion.
 *
 * It fetches the administrator record by email from the
 * communitybbs_administrator table, then deletes all associated sessions from
 * the communitybbs_session table (with CASCADE on admin_id). Finally, it
 * deletes the administrator record itself from the communitybbs_administrator
 * table.
 *
 * A permanent log entry is created in the communitybbs_log table with
 * action_type 'administrator_deleted', recording the operator and the deleted
 * administrator’s identity.
 *
 * The email address is freed and may be reused. No data related to this
 * administrator is retained in the active system. This deletion is completely
 * irreversible.
 *
 * This operation is reserved for extreme circumstances: administrator
 * departure, security breaches, or legal requirement. It is always accompanied
 * by an audit trail and fail-safes to prevent accidental removal.
 *
 * @param props.connection
 * @param props.email The email address of the administrator to delete
 *   permanently.
 * @path /admin/administrators/:email
 * @accessor api.functional.admin.administrators.eraseAdministrator
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseAdministrator(
  connection: IConnection,
  props: eraseAdministrator.Props,
): Promise<eraseAdministrator.Response> {
  return true === connection.simulate
    ? eraseAdministrator.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseAdministrator.METADATA,
          path: eraseAdministrator.path(props),
          status: null,
        },
      );
}
export namespace eraseAdministrator {
  export type Props = {
    /** The email address of the administrator to delete permanently. */
    email: string & tags.Format<"email">;
  };
  export type Response = IResponseEmpty;

  export const METADATA = {
    method: "DELETE",
    path: "/admin/administrators/:email",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/administrators/${encodeURIComponent(props.email ?? "null")}`;
  export const random = (): IResponseEmpty => typia.random<IResponseEmpty>();
  export const simulate = (
    connection: IConnection,
    props: eraseAdministrator.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseAdministrator.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
