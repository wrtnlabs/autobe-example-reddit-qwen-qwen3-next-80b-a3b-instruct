import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsMember } from "../../../structures/ICommunitybbsMember";
import { IResponseEmpty } from "../../../structures/IResponseEmpty";

/**
 * View member account details (Admin only).
 *
 * This endpoint allows administrators to view detailed information about a
 * registered member account stored in the communitybbs_member table.
 *
 * The system looks up the member either by email (provided in path) or by ID
 * (if supported in future). It returns the following fields: id, email,
 * display_name, created_at, updated_at. The password_hash is never returned.
 * This information is used for moderation purposes such as reviewing account
 * activity, verifying identity, or diagnosing reports.
 *
 * The operation includes a timestamp of the member’s last active session by
 * joining with the communitybbs_session table (most recent session where
 * is_valid = true). This provides context on whether the member is active or
 * dormant.
 *
 * No post, comment, or vote history is included in the response to preserve
 * privacy and limit data exposure. The endpoint is read-only and does not
 * modify any data.
 *
 * This endpoint supports only administrative access and is not available to
 * regular members. This ensures that privacy is maintained while enabling
 * moderation workflows.
 *
 * @param props.connection
 * @param props.email The email address of the member to inspect.
 * @path /admin/members/:email
 * @accessor api.functional.admin.members.atMember
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function atMember(
  connection: IConnection,
  props: atMember.Props,
): Promise<atMember.Response> {
  return true === connection.simulate
    ? atMember.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...atMember.METADATA,
          path: atMember.path(props),
          status: null,
        },
      );
}
export namespace atMember {
  export type Props = {
    /** The email address of the member to inspect. */
    email: string & tags.Format<"email">;
  };
  export type Response = ICommunitybbsMember;

  export const METADATA = {
    method: "GET",
    path: "/admin/members/:email",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/members/${encodeURIComponent(props.email ?? "null")}`;
  export const random = (): ICommunitybbsMember =>
    typia.random<ICommunitybbsMember>();
  export const simulate = (
    connection: IConnection,
    props: atMember.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: atMember.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a member and all their content (Admin only).
 *
 * This endpoint permanently deletes a member's account and all their
 * contributions, removing their data entirely from the system.
 *
 * The system identifies the member by email, then begins a cascading delete
 * process: all sessions in communitybbs_session (where actor_id matches), all
 * votes in communitybbs_vote (where actor_id matches), all comments in
 * communitybbs_comment (where communitybbs_member_id matches), all posts in
 * communitybbs_post (where communitybbs_member_id matches), and finally the
 * member record itself in communitybbs_member.
 *
 * The deletion is atomic, ensuring no orphaned data remains. A hard delete is
 * performed — the data is completely removed from the database.
 *
 * A detailed log entry is created in the communitybbs_log table with
 * action_type 'member_permanently_deleted', including the operator's identity
 * and the email of the deleted member.
 *
 * This operation is irreversible and the member's email may be reused. It is
 * intended only for legal compliance (GDPR, CCPA), severe abuse that requires
 * censorship, or formal user requests for complete removal. Use with extreme
 * caution.
 *
 * @param props.connection
 * @param props.email The email address of the member to delete permanently.
 * @path /admin/members/:email
 * @accessor api.functional.admin.members.eraseMember
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseMember(
  connection: IConnection,
  props: eraseMember.Props,
): Promise<eraseMember.Response> {
  return true === connection.simulate
    ? eraseMember.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseMember.METADATA,
          path: eraseMember.path(props),
          status: null,
        },
      );
}
export namespace eraseMember {
  export type Props = {
    /** The email address of the member to delete permanently. */
    email: string & tags.Format<"email">;
  };
  export type Response = IResponseEmpty;

  export const METADATA = {
    method: "DELETE",
    path: "/admin/members/:email",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/members/${encodeURIComponent(props.email ?? "null")}`;
  export const random = (): IResponseEmpty => typia.random<IResponseEmpty>();
  export const simulate = (
    connection: IConnection,
    props: eraseMember.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseMember.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Ban a member from the platform (Admin only).
 *
 * This endpoint bans a member from the platform, effectively blocking their
 * access while preserving content history.
 *
 * The system identifies the member by their email, then locates all active
 * sessions (where is_valid = true) in the communitybbs_session table, and
 * permanently marks them as deleted by setting deleted_at to the current
 * timestamp and is_valid to false.
 *
 * The member's record in the communitybbs_member table is not deleted. Their
 * email, username, and historical contributions remain intact. They are
 * prevented from authenticating any further; login attempts will be denied.
 *
 * A log entry is created in the communitybbs_log table with action_type
 * 'member_banned' and includes the moderator's ID and the reason (if provided).
 * The ban is immutable and requires restoration via a separate endpoint.
 *
 * This is a reputation action, not a deletion. Posts and comments created by
 * the member remain visible to maintain context and allow community review. The
 * ban does not affect post votes or comment threads.
 *
 * To reinstate access, the administrator must use the restore membership
 * endpoint.
 *
 * @param props.connection
 * @param props.email The email address of the member to ban.
 * @path /admin/members/:email/ban
 * @accessor api.functional.admin.members.ban
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function ban(
  connection: IConnection,
  props: ban.Props,
): Promise<ban.Response> {
  return true === connection.simulate
    ? ban.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...ban.METADATA,
          path: ban.path(props),
          status: null,
        },
      );
}
export namespace ban {
  export type Props = {
    /** The email address of the member to ban. */
    email: string & tags.Format<"email">;
  };
  export type Response = ICommunitybbsMember;

  export const METADATA = {
    method: "PUT",
    path: "/admin/members/:email/ban",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/members/${encodeURIComponent(props.email ?? "null")}/ban`;
  export const random = (): ICommunitybbsMember =>
    typia.random<ICommunitybbsMember>();
  export const simulate = (
    connection: IConnection,
    props: ban.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: ban.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Restore banned member access (Admin only).
 *
 * This endpoint reinstates access for a previously banned member by allowing
 * new session creation.
 *
 * The system looks up the member by their email in the communitybbs_member
 * table. It does not restore any old sessions; instead, it permits future
 * sessions to be generated upon successful login. No existing deleted sessions
 * are retrieved.
 *
 * The member's data (email, display_name, created_at) remains unchanged. The
 * ban status is considered resolved, and the member may attempt to log in
 * again.
 *
 * If the member attempts to log in, the authentication flow proceeds normally,
 * and a new session is created. The previous inactive sessions remain deleted
 * for audit purposes.
 *
 * A log entry is created in the communitybbs_log table with action_type
 * 'member_unbanned', recording the administrator who performed the action and
 * the member's identity.
 *
 * This operation does not delete the ban history; it only re-enables the
 * account. The track record of past violations remains intact for review and
 * analytics.
 *
 * @param props.connection
 * @param props.email The email address of the member to unban.
 * @path /admin/members/:email/unban
 * @accessor api.functional.admin.members.unban
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function unban(
  connection: IConnection,
  props: unban.Props,
): Promise<unban.Response> {
  return true === connection.simulate
    ? unban.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...unban.METADATA,
          path: unban.path(props),
          status: null,
        },
      );
}
export namespace unban {
  export type Props = {
    /** The email address of the member to unban. */
    email: string & tags.Format<"email">;
  };
  export type Response = ICommunitybbsMember;

  export const METADATA = {
    method: "PUT",
    path: "/admin/members/:email/unban",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/members/${encodeURIComponent(props.email ?? "null")}/unban`;
  export const random = (): ICommunitybbsMember =>
    typia.random<ICommunitybbsMember>();
  export const simulate = (
    connection: IConnection,
    props: unban.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: unban.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("email")(() => typia.assert(props.email));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
