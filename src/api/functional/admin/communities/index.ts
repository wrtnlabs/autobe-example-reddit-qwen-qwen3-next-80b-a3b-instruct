import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsCommunity } from "../../../structures/ICommunitybbsCommunity";
export * as permanent_delete from "./permanent_delete/index";

/**
 * Get full details of a community by name (Admin only).
 *
 * This endpoint retrieves a specific community by its name identifier for
 * administrative review.
 *
 * The system looks up the community in the communitybbs_community table using
 * the name parameter (case-insensitive lookup). If the community exists, the
 * full record is returned including id, description, category, logo, banner,
 * rules, created_at, updated_at, deleted_at, member_count, and last_active_at.
 * This endpoint returns soft-deleted records (where deleted_at is not null)
 * unlike the public API, enabling administrators to view and potentially
 * restore archived communities.
 *
 * The response includes all fields as stored in the schema, including the rules
 * array as a JSON string and the image URLs. No filtering is applied based on
 * user access rights; administrators always see the complete state. This
 * operation is read-only and does not affect any data.
 *
 * This endpoint is used in moderation dashboards, recovery workflows, or
 * compliance audits where visibility into historical or inactive communities is
 * required. The name parameter is a required path variable that must match
 * exactly with the unique index constraint on the name field in the community
 * table.
 *
 * @param props.connection
 * @param props.name The unique name identifier of the community (e.g., 'ai',
 *   'retro-gaming'). Case-insensitive, must match exactly.
 * @path /admin/communities/:name
 * @accessor api.functional.admin.communities.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /**
     * The unique name identifier of the community (e.g., 'ai',
     * 'retro-gaming'). Case-insensitive, must match exactly.
     */
    name: string &
      tags.MinLength<3> &
      tags.MaxLength<32> &
      tags.Pattern<"^[a-z0-9_-]+$">;
  };
  export type Response = ICommunitybbsCommunity;

  export const METADATA = {
    method: "GET",
    path: "/admin/communities/:name",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/communities/${encodeURIComponent(props.name ?? "null")}`;
  export const random = (): ICommunitybbsCommunity =>
    typia.random<ICommunitybbsCommunity>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("name")(() => typia.assert(props.name));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update community metadata (Admin only).
 *
 * This endpoint allows administrators to update the metadata of an existing
 * community in the communitybbs_community table.
 *
 * Fields that can be modified: name, category, description, rules, logo,
 * banner. The name field can be changed, but must remain unique among all
 * communities (case-insensitive). If the name changes, the system automatically
 * updates all related search index entries in communitybbs_search_post and
 * communitybbs_search_comment to reflect the new name, ensuring search
 * consistency.
 *
 * The category must be from the predefined list. The rules field, if updated,
 * must be a JSON-encoded array of strings, each â‰¤100 characters with a maximum
 * of 10 rules. The logo and banner URLs are updated as strings, but not
 * validated for content or existence.
 *
 * The updated_at timestamp is automatically set to the current time. The
 * operation is atomic and will fail if the name violates the unique constraint
 * or any text field exceeds its maximum length.
 *
 * This workflow allows administrators to correct mistakes, reorganize
 * categorization, update guidelines, or modernize branding. Changes are
 * persisted immediately and reflected in all UIs that display the community.
 * This endpoint does not affect membership status or posts within the
 * community.
 *
 * @param props.connection
 * @param props.name The current unique name identifier of the community to
 *   update.
 * @param props.body Patch payload containing fields to update. Only specified
 *   fields are modified.
 * @path /admin/communities/:name
 * @accessor api.functional.admin.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The current unique name identifier of the community to update. */
    name: string &
      tags.MinLength<3> &
      tags.MaxLength<32> &
      tags.Pattern<"^[a-z0-9_-]+$">;

    /**
     * Patch payload containing fields to update. Only specified fields are
     * modified.
     */
    body: ICommunitybbsCommunity.IUpdate;
  };
  export type Body = ICommunitybbsCommunity.IUpdate;
  export type Response = ICommunitybbsCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/admin/communities/:name",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/admin/communities/${encodeURIComponent(props.name ?? "null")}`;
  export const random = (): ICommunitybbsCommunity =>
    typia.random<ICommunitybbsCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("name")(() => typia.assert(props.name));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete a community (Admin only).
 *
 * This endpoint soft-deletes a community, archiving it from public view without
 * permanent data destruction.
 *
 * The system locates the community by name in the communitybbs_community table
 * and sets the deleted_at field to the current timestamp. This causes the
 * community to be excluded from all public queries (Home feed, Explore page,
 * Search results, etc.) but retains all related data: posts, comments, votes,
 * and logs.
 *
 * The operation triggers an update to the search index tables
 * (communitybbs_search_community, communitybbs_search_post,
 * communitybbs_search_comment) to ensure the content is hidden from search
 * results. The member_count is preserved, and last_active_at is not updated.
 *
 * A log entry is created in the communitybbs_log table with action_type
 * 'community_deleted', linking to the deleted community and the administrator
 * who performed the action.
 *
 * This operation is reversible. Setting deleted_at to null via an update
 * operation will restore the community to full visibility. The community name
 * remains reserved and cannot be reused until the community is restored.
 *
 * Soft-delete is preferred over hard-delete to preserve historical integrity,
 * enable audit recovery, and comply with data retention policies.
 *
 * @param props.connection
 * @param props.name The name identifier of the community to delete.
 * @path /admin/communities/:name
 * @accessor api.functional.admin.communities.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<erase.Response> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The name identifier of the community to delete. */
    name: string &
      tags.MinLength<3> &
      tags.MaxLength<32> &
      tags.Pattern<"^[a-z0-9_-]+$">;
  };
  export type Response = ICommunitybbsCommunity;

  export const METADATA = {
    method: "DELETE",
    path: "/admin/communities/:name",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/admin/communities/${encodeURIComponent(props.name ?? "null")}`;
  export const random = (): ICommunitybbsCommunity =>
    typia.random<ICommunitybbsCommunity>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("name")(() => typia.assert(props.name));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
