import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsPost } from "../../../../structures/ICommunitybbsPost";
import { IPageICommunitybbsPost } from "../../../../structures/IPageICommunitybbsPost";

/**
 * Search and retrieve paginated posts from a specific community.
 *
 * Retrieve an ordered and paginated list of posts from a specific community,
 * filtered by the provided search criteria. This operation supports advanced
 * filtering using the request body, including sort order (Newest or Top),
 * limit, offset, and text search. For the 'Newest' sort order, results are
 * sorted by creation_time descending, and then by post_id descending for ties.
 * For the 'Top' sort order, results are sorted by score (upvotes minus
 * downvotes) descending, followed by creation_time descending, and finally by
 * post_id descending. The operation only returns posts where deleted_at is
 * null, ensuring archived posts are excluded. The results are constructed by
 * querying the communitybbs_post table, using the communitybbs_community_id as
 * the filter, and joined with the communitybbs_vote table to compute scores.
 * The communitybbs_search_post table is not used here because this endpoint is
 * community-specific and does not require full-text search across the whole
 * platform — instead, it performs standard database queries optimized for range
 * and index scans on the community-specific post set. Pagination is implemented
 * via offset and limit, fetching exactly 20 posts per page as per requirements.
 * This endpoint must be accessible to all authenticated users and reflects the
 * user's joined community state — if the user has not joined the community, the
 * results are still accessible (read-only), matching the public nature of
 * community posts. No role restrictions are needed because posts within
 * communities are publicly readable by design.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to retrieve posts
 *   from.
 * @param props.body Search criteria and pagination parameters for filtering
 *   posts within a community.
 * @path /communitybbs/communities/:communityId/posts
 * @accessor api.functional.communitybbs.communities.posts.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Unique identifier of the community to retrieve posts from. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Search criteria and pagination parameters for filtering posts within
     * a community.
     */
    body: ICommunitybbsPost.IRequest;
  };
  export type Body = ICommunitybbsPost.IRequest;
  export type Response = IPageICommunitybbsPost;

  export const METADATA = {
    method: "PATCH",
    path: "/communitybbs/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communitybbs/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): IPageICommunitybbsPost =>
    typia.random<IPageICommunitybbsPost>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve the full details of a specific post.
 *
 * Retrieve the detailed information of a specific post, identified by its
 * unique post ID within the context of its community. This operation returns
 * the complete post object with all its fields: title, body, author display
 * name (as captured at time of creation), creation timestamp, update timestamp,
 * member count, and score (calculated as upvotes minus downvotes). The system
 * verifies that the target post belongs to the specified community and that the
 * post has not been soft-deleted (deleted_at is null). This operation does not
 * return associated comments — those are available via a separate endpoint at
 * /communities/{communityId}/posts/{postId}/comments. This endpoint is designed
 * to support public viewability; any user — guest or authenticated — may access
 * a post detail page. The query joins the communitybbs_post table with the
 * communitybbs_community table to confirm relationship and with the
 * communitybbs_vote table to compute the score using sum conditions. No user
 * role restrictions are needed because access to post content is public by
 * design, as specified in the requirements. The response is optimized for
 * frontend rendering and includes all required metadata for rendering the post
 * detail page without requiring additional API calls. This endpoint must
 * maintain high performance because it is frequently accessed during user
 * navigation.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community containing the
 *   post.
 * @param props.postId Unique identifier of the post to retrieve.
 * @path /communitybbs/communities/:communityId/posts/:postId
 * @accessor api.functional.communitybbs.communities.posts.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the community containing the post. */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the post to retrieve. */
    postId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunitybbsPost;

  export const METADATA = {
    method: "GET",
    path: "/communitybbs/communities/:communityId/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communitybbs/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunitybbsPost =>
    typia.random<ICommunitybbsPost>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
