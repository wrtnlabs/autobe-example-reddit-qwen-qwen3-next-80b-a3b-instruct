import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsCommunity } from "../../../../structures/ICommunitybbsCommunity";
export * as posts from "./posts/index";

/**
 * Create a new community with the provided name, description, category, logo,
 * banner, and rules configuration. This operation handles the community
 * creation workflow as defined in the requirements, including validation of
 * community name format and uniqueness.
 *
 * The community name must adhere to the strict format rules: only alphanumeric
 * characters, hyphens (-), and underscores (_) are permitted, with a length
 * between 3 and 32 characters. The name must be unique across all existing
 * communities, and the system performs a case-insensitive check to prevent
 * duplicates with different casing.
 *
 * The description field is limited to 500 characters as specified in the
 * requirements. The category must be one of the predefined values: ["Tech &
 * Programming", "Science", "Movies & TV", "Games", "Sports", "Lifestyle &
 * Wellness", "Study & Education", "Art & Design", "Business & Finance", "News &
 * Current Affairs"]. The rules field is stored as a JSON-encoded array of
 * strings, each up to 100 characters, with a maximum of 10 rules permitted.
 *
 * The logo and banner fields are optional URLs stored as text fields with
 * maximum length of 80,000 characters to accommodate long URLs, but the system
 * enforces size and format constraints at the application layer.
 *
 * When a community is successfully created, the system records the creation
 * timestamp, initializes the member_count to 1 (the creator), and sets the
 * last_active_at timestamp. The community is not associated with any member
 * record at this level - that relationship is handled through a separate
 * junction table (communitybbs_member_community) that is not exposed in this
 * API.
 *
 * Security considerations require that only authenticated users (members) can
 * create a community, which is handled by the authorizationRoles field (member)
 * and validated through session authentication. The operation ensures that no
 * community with the same name exists through a unique constraint on
 * communitybbs_community.name.
 *
 * Related operations include the PATCH /communities for searching communities
 * and the PUT /communities/{communityId} for updating community details after
 * creation. This operation does not create associated search index entries -
 * that is handled by a background process that synchronizes with
 * communitybbs_search_community.
 *
 * @param props.connection
 * @param props.body Creation data for a new community
 * @path /communitybbs/member/communities
 * @accessor api.functional.communitybbs.member.communities.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Creation data for a new community */
    body: ICommunitybbsCommunity.ICreate;
  };
  export type Body = ICommunitybbsCommunity.ICreate;
  export type Response = ICommunitybbsCommunity;

  export const METADATA = {
    method: "POST",
    path: "/communitybbs/member/communities",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communitybbs/member/communities";
  export const random = (): ICommunitybbsCommunity =>
    typia.random<ICommunitybbsCommunity>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a community's details.
 *
 * Update an existing community's description, category, visual assets (logo and
 * banner), or community rules. This operation enables community creators to
 * modify their community's metadata after creation.
 *
 * The operation validates that the authenticated user is the creator of the
 * community (based on ownership) and only allows updates to specified fields:
 * description, category, logo, banner, and rules. The community name is
 * immutable after creation, as specified in the requirements - any attempt to
 * modify the name will result in an error.
 *
 * Field validation rules must be strictly enforced: description must not exceed
 * 500 characters, category must be one of the predefined values, logo and
 * banner URLs must be valid strings (up to 80,000 characters), and rules must
 * be a JSON array containing up to 10 strings with a maximum of 100 characters
 * each.
 *
 * The updated_at timestamp is automatically updated to the current time when
 * any change is accepted. The last_active_at timestamp is also updated to
 * reflect the most recent activity, ensuring the community remains visible in
 * the 'Recent Communities' list.
 *
 * Security considerations require the operation to authenticate the user's
 * session and verify ownership before processing any updates. The system
 * prevents unauthorized access by checking that the authenticated member's ID
 * matches the creator's identity associated with the community.
 *
 * Related operations include the POST /communities for community creation and
 * the GET /communities/{communityId} for retrieving community details. This
 * operation does not affect the member_count or the community name, which
 * remain immutable after creation as per business requirements.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community
 * @param props.body Update data for the community
 * @path /communitybbs/member/communities/:communityId
 * @accessor api.functional.communitybbs.member.communities.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target community */
    communityId: string & tags.Format<"uuid">;

    /** Update data for the community */
    body: ICommunitybbsCommunity.IUpdate;
  };
  export type Body = ICommunitybbsCommunity.IUpdate;
  export type Response = ICommunitybbsCommunity;

  export const METADATA = {
    method: "PUT",
    path: "/communitybbs/member/communities/:communityId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communitybbs/member/communities/${encodeURIComponent(props.communityId ?? "null")}`;
  export const random = (): ICommunitybbsCommunity =>
    typia.random<ICommunitybbsCommunity>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
