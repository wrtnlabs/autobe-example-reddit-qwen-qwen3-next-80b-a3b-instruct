import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunitybbsPost } from "../../../../../structures/ICommunitybbsPost";
export * as comments from "./comments/index";
export * as votes from "./votes/index";

/**
 * Create a new post in a specified community.
 *
 * Create a new post in the specified community. This operation requires the
 * user to be authenticated as a member and to submit a valid title and body.
 * The title must be between 5 and 120 characters and the body between 10 and
 * 10,000 characters, as per requirements. The body content must be plain text
 * only, with no HTML, scripts, or code allowed — any attempt to include these
 * will be rejected. The author's display name is captured at the time of
 * submission and stored as part of the post for consistency, even if the member
 * later changes their display name. If no display name is provided, the system
 * defaults to 'Anonymous'. The new post is associated with the given community
 * via the communityId path parameter and the authenticated member’s ID. Upon
 * successful creation, the community's last_active_at timestamp is updated to
 * the current time, and the post count is incremented internally. The post is
 * immediately available in the community feed and is indexed in the search
 * system. This operation does not require soft delete handling during
 * submission because the post is created in active state only; soft deletion is
 * a permissioned moderation action handled separately. The post is created as a
 * direct user-initiated action, not a system-generated record, and must be
 * trackable to the user who submitted it. This endpoint is protected — guests
 * cannot create posts and will be redirected to login. Only the member role has
 * permission to invoke this endpoint.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the community to which the post
 *   will be added.
 * @param props.body Creation data for a new post, including title, body, and
 *   optional display name.
 * @path /communitybbs/member/communities/:communityId/posts
 * @accessor api.functional.communitybbs.member.communities.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the community to which the post will be added. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Creation data for a new post, including title, body, and optional
     * display name.
     */
    body: ICommunitybbsPost.ICreate;
  };
  export type Body = ICommunitybbsPost.ICreate;
  export type Response = ICommunitybbsPost;

  export const METADATA = {
    method: "POST",
    path: "/communitybbs/member/communities/:communityId/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communitybbs/member/communities/${encodeURIComponent(props.communityId ?? "null")}/posts`;
  export const random = (): ICommunitybbsPost =>
    typia.random<ICommunitybbsPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing post by ID.
 *
 * This operation updates an existing post within a community. It operates on
 * the communitybbs_post table from the Prisma schema. The post can only be
 * updated by its original author. Updates are subject to content length
 * restrictions as defined in business requirements (title: 5-120 characters,
 * body: 10-10,000 characters). This endpoint enables users to correct content
 * or improve posts after submission.
 *
 * Security considerations mandate that only the original author of a post can
 * modify it. The system enforces ownership verification through the
 * communitybbs_member_id relationship. If a user attempts to update a post they
 * did not author, the system returns a forbidden response with the message 'You
 * can edit or delete only items you authored.' This protection prevents
 * unauthorized modification of others' content.
 *
 * This operation integrates with the communitybbs_post table as defined in the
 * Prisma schema. The request payload includes the updated title and body
 * content. The response returns the updated post entity including its
 * updated_at timestamp, which is automatically set by the service layer. The
 * updated_at field ensures clients receive the latest update information for
 * optimal UI consistency.
 *
 * Validation rules strictly enforce the content length requirements: titles
 * must be at least 5 characters long and no more than 120 characters; bodies
 * must be at least 10 characters long and no more than 10,000 characters. The
 * system also validates that the post exists, belongs to the specified
 * community, and that the user is the author. If the content violates these
 * constraints, the system returns a 400 Bad Request error with appropriate
 * messages such as 'Title must be between 5 and 120 characters.' or 'Body must
 * be between 10 and 10,000 characters.'
 *
 * Related API operations include retrieving a specific post (GET
 * /communities/{communityId}/posts/{postId}), creating new posts (POST
 * /communities/{communityId}/posts), and deleting posts (DELETE
 * /communities/{communityId}/posts/{postId}). This 'update' operation is the
 * primary method for post editing in the UI.
 *
 * Note: The system does not include a deleted_at field in the communitybbs_post
 * table, so there is no soft-delete capability. The edit operation directly
 * modifies the post data without preservation of previous versions.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community
 * @param props.postId Unique identifier of the target post
 * @param props.body Updated post title and body content
 * @path /communitybbs/member/communities/:communityId/posts/:postId
 * @accessor api.functional.communitybbs.member.communities.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the target community */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the target post */
    postId: string & tags.Format<"uuid">;

    /** Updated post title and body content */
    body: ICommunitybbsPost.IUpdate;
  };
  export type Body = ICommunitybbsPost.IUpdate;
  export type Response = ICommunitybbsPost;

  export const METADATA = {
    method: "PUT",
    path: "/communitybbs/member/communities/:communityId/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communitybbs/member/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunitybbsPost =>
    typia.random<ICommunitybbsPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Permanently delete a post by ID.
 *
 * This operation permanently deletes a specific post within a community. It
 * operates on the communitybbs_post table from the Prisma schema. The post can
 * only be deleted by its original author or an administrator. This endpoint
 * implements hard deletion as there is no deleted_at field in the schema,
 * removing the post completely from the database along with all associated
 * comments and votes.
 *
 * Per the Prisma schema, the communitybbs_post table does not include a
 * deleted_at field, indicating that deletion is permanent rather than soft
 * deletion. When a post is deleted, all associated data is removed from the
 * database, including all related comments and votes. The deletion cascades
 * automatically through the database foreign key constraints with ON DELETE
 * CASCADE configured. There is no recovery mechanism.
 *
 * Security considerations include strict ownership verification. Only the
 * original author of a post or an administrator can delete a post. If an
 * unauthorized user attempts deletion, the system returns a 403 Forbidden
 * response with the message 'You can edit or delete only items you authored.'
 * This ensures content integrity and prevents unauthorized removal of user
 * content.
 *
 * The system follows the business requirement that posts can be deleted by
 * their authors, but cannot be deleted by other users without administrative
 * privileges. The operation does not return any response body as per standard
 * practice for DELETE operations, with success indicated by a 204 No Content
 * response.
 *
 * Related API operations include retrieving a specific post (GET
 * /communities/{communityId}/posts/{postId}), updating a post (PUT
 * /communities/{communityId}/posts/{postId}), and retrieving all comments for a
 * post (PATCH /communities/{communityId}/posts/{postId}/comments). This 'erase'
 * operation is the primary method for post removal in the UI.
 *
 * Note: The communitybbs_post table in the schema has no soft-delete
 * capability, so there is no deleted_at field. Deletion removes all associated
 * data permanently.
 *
 * @param props.connection
 * @param props.communityId Unique identifier of the target community
 * @param props.postId Unique identifier of the target post
 * @path /communitybbs/member/communities/:communityId/posts/:postId
 * @accessor api.functional.communitybbs.member.communities.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the target community */
    communityId: string & tags.Format<"uuid">;

    /** Unique identifier of the target post */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communitybbs/member/communities/:communityId/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communitybbs/member/communities/${encodeURIComponent(props.communityId ?? "null")}/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
