import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IMember } from "../../../structures/IMember";
import { ICommunityPlatformMember } from "../../../structures/ICommunityPlatformMember";

/**
 * Create new member account with email and password hash for authentication.
 *
 * This API operation creates a new member account in the communityPlatform
 * system, enabling users to become authenticated participants. It maps directly
 * to the community_platform_member table where the account's email,
 * password_hash, and created_at fields are persisted.
 *
 * The operation requires the user to provide a valid email address and
 * password, which are securely stored in the system. The email field is unique
 * across all members and is used as the primary identifier for authentication.
 * The password is hashed using industry-standard cryptographic methods before
 * being stored, ensuring security compliance. The created_at timestamp is
 * automatically generated upon record creation.
 *
 * This functionality supports the member role's requirement to join the
 * platform, complementing the login and refresh operations for full
 * authentication flow. It aligns with the business rule that member accounts
 * are needed for posting, commenting, voting, joining communities, and creating
 * communities.
 *
 * Security considerations include ensuring HTTPS transport, enforcing strong
 * password policies, and validating email format. The schema explicitly
 * includes both email and password_hash fields which are required for this
 * operation, and no other fields from the member table are necessary for
 * initial account creation.
 *
 * This join operation is the first step in a member's journey on the platform,
 * enabling them to subsequently perform login and refresh operations to
 * maintain their authenticated session. Without successful execution of this
 * operation, users remain in guest mode with limited functionality.
 *
 * @param props.connection
 * @param props.body Payload containing registration credentials for a new
 *   member account.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @accessor api.functional.auth.member.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /** Payload containing registration credentials for a new member account. */
    body: IMember.IJoin;
  };
  export type Body = IMember.IJoin;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate member with email and password to generate access and refresh
 * tokens.
 *
 * This API operation authenticates an existing member using email and password
 * credentials to establish a secure session. It validates the provided
 * credentials against the community_platform_member table, specifically
 * checking the email field for existence and the password_hash field for
 * cryptographic match.
 *
 * The operation takes an email and password as input, verifies that the email
 * corresponds to an active member account (deleted_at field is null), and
 * confirms the password matches the stored hash using bcrypt or similar secure
 * algorithm. Upon successful verification, it generates a JWT access token with
 * a 30-minute expiration and a refresh token with a 30-day expiration as per
 * the system's authentication policy.
 *
 * This functionality supports the member role's requirement to authenticate and
 * access protected operations like posting, commenting, voting, joining
 * communities, and creating communities. The schema contains both email and
 * password_hash fields which are required for this authentication check, making
 * this operation directly supported by the database structure.
 *
 * Security considerations include using HTTPS for transport, implementing rate
 * limiting to prevent brute force attacks, and ensuring tokens are stored
 * securely on the client side. The generated tokens are signed with a secret
 * key and contain the user's ID and role information for authorization
 * purposes.
 *
 * This login operation works in conjunction with the join and refresh
 * operations to form a complete authentication workflow, allowing members to
 * securely interact with all protected features of the community platform.
 *
 * @param props.connection
 * @param props.body Credentials for authenticating an existing member account.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @accessor api.functional.auth.member.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Credentials for authenticating an existing member account. */
    body: IMember.ILogin;
  };
  export type Body = IMember.ILogin;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access token using valid refresh token to extend member session
 * without re-authentication.
 *
 * This API operation refreshes the JWT access token for an authenticated member
 * using a valid refresh token. It validates the refresh token signature and
 * checks that the underlying member account is still active (deleted_at field
 * is null).
 *
 * When a refresh request is received, the system verifies the refresh token's
 * integrity and expiry, then checks the associated member account in the
 * community_platform_member table. If the account is active, it generates a new
 * access token with a fresh 30-minute expiration while preserving the 30-day
 * refresh token. The last_login_at field is updated to reflect the most recent
 * authentic activity, helping track user sessions and implement session
 * management policies.
 *
 * This refresh functionality supports the member role's authentication
 * requirements by enabling users to maintain continuous access to protected
 * features like posting, commenting, voting, joining communities, and creating
 * communities without requiring re-authentication with their credentials. This
 * improves user experience while maintaining security boundaries.
 *
 * The operation depends on the member table's existence and validates against
 * its structure. The refresh flow is essential for the platform's session
 * management strategy, complementing the login and join operations to form a
 * complete authentication cycle.
 *
 * Security considerations include token revocation lists for compromised
 * tokens, secure token storage on the client side, and protection against token
 * theft or replay attacks.
 *
 * @param props.connection
 * @param props.body Refresh token to extend the member's authenticated session.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @accessor api.functional.auth.member.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /** Refresh token to extend the member's authenticated session. */
    body: IMember.IRefresh;
  };
  export type Body = IMember.IRefresh;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
