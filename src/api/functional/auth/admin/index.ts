import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdmin } from "../../../structures/ICommunityPlatformAdmin";

/**
 * Register a new admin user by creating a member account and elevating to admin
 * privilege.
 *
 * This API operation handles registration for admin users on the community
 * platform. The operation follows a two-step process consistent with the Prisma
 * schema: first, it creates a new member account in the
 * community_platform_member table with required fields including email,
 * password_hash (for authentication), and optional display_name. Then, it
 * creates a corresponding admin record in the community_platform_admin table
 * that references the member_id, establishing the admin privilege level. This
 * two-table approach ensures separation of concerns between authentication
 * credentials and privilege levels. The community_platform_member table
 * contains all necessary fields for user registration: email (unique
 * identifier), password_hash (mandatory for secure authentication), and
 * optional display_name (up to 32 characters). The operation does not create
 * the admin record first because admin privileges are granted to existing
 * members, not as standalone entities. The success of this operation depends on
 * the existence and proper validation of the community_platform_member schema
 * fields. The operation handles new user registration for the admin role only
 * and requires the user to provide valid credentials that satisfy the member
 * creation constraints defined in the schema.
 *
 * @param props.connection
 * @param props.body Request body for admin registration containing
 *   authentication credentials and optional display name as defined in the
 *   community_platform_member schema.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @accessor api.functional.auth.admin.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Request body for admin registration containing authentication
     * credentials and optional display name as defined in the
     * community_platform_member schema.
     */
    body: ICommunityPlatformAdmin.IJoin;
  };
  export type Body = ICommunityPlatformAdmin.IJoin;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin user with email and password to obtain JWT tokens.
 *
 * This API operation handles the authentication process for admin users on the
 * community platform. It validates user credentials against the
 * community_platform_member table, specifically checking the email field that
 * serves as the unique identifier and the password_hash field that contains the
 * hashed authentication credential. These fields are mandatory according to the
 * Prisma schema definition of the community_platform_member table. The
 * operation accepts an email address and password (which is hashed server-side)
 * and verifies them against the stored values in the database. Upon successful
 * validation, the system generates JWT access and refresh tokens to manage the
 * user's session. The operation does not interact with any other tables or
 * fields for authentication purposes, as the membership authentication logic is
 * contained entirely within the community_platform_member table with its
 * defined fields: email and password_hash. The operation returns a standardized
 * response format that conforms to the ICommunityPlatformAdmin.IAuthorized
 * schema, containing the access and refresh tokens. The response does not
 * include sensitive user data beyond what's necessary for session management,
 * following security best practices.
 *
 * @param props.connection
 * @param props.body Request body containing authentication credentials for
 *   admin login, including email address and password as defined in
 *   community_platform_member schema.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @accessor api.functional.auth.admin.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Request body containing authentication credentials for admin login,
     * including email address and password as defined in
     * community_platform_member schema.
     */
    body: ICommunityPlatformAdmin.ILogin;
  };
  export type Body = ICommunityPlatformAdmin.ILogin;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh expired admin access token using a refresh token to maintain
 * authenticated session.
 *
 * This API operation handles the token refresh process for admin users on the
 * community platform. When a user's access token expires (typically after 30
 * minutes), this operation allows them to obtain a new access token without
 * re-entering credentials. The operation requires a valid refresh token that
 * was issued during the initial login or registration process. The refresh
 * token is validated against the system's secure token store, which maintains
 * persistence of valid refresh tokens associated with the user's member account
 * in the community_platform_member table. The operation does not interact with
 * any other schema fields beyond token validation; it does not require
 * password_hash, email, or display_name fields from the member table as these
 * are not needed once authentication has been established. The operation
 * follows the standard refresh protocol where a valid refresh token triggers
 * the issuance of a new access token while the refresh token itself remains
 * valid for future use (or is renewed based on policy). The response conforms
 * to the standardized authentication response format using the
 * ICommunityPlatformAdmin.IAuthorized schema, ensuring consistent response
 * structure across all authentication operations. This approach maintains
 * session continuity while enhancing security through short-lived access
 * tokens.
 *
 * @param props.connection
 * @param props.body Request body containing the refresh token to obtain a new
 *   access token. The refresh token is issued during join or login operations
 *   and stored securely on the client side.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @accessor api.functional.auth.admin.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Request body containing the refresh token to obtain a new access
     * token. The refresh token is issued during join or login operations
     * and stored securely on the client side.
     */
    body: ICommunityPlatformAdmin.IRefresh;
  };
  export type Body = ICommunityPlatformAdmin.IRefresh;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
