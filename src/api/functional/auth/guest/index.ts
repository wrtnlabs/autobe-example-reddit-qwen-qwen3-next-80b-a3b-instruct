import { IConnection } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { ICommunityPlatformGuest } from "../../../structures/ICommunityPlatformGuest";

/**
 * Creates temporary guest account for read-only access to public content.
 *
 * This API operation generates a temporary guest session for unauthenticated
 * users who wish to browse public content on the community platform. The guest
 * account enables users to view all posts, comments, and communities while
 * restricting access to interactive features like posting, commenting, voting,
 * and community membership—all of which require proper authentication.
 *
 * The operation creates an entry in the community_platform_guest table with a
 * unique UUID identifier and an audit timestamp, capturing the IP address if
 * available for analytics and spam detection purposes. This temporary session
 * does not persist user preferences or account details, ensuring compliance
 * with the platform security model where only authenticated members have
 * persistent identities.
 *
 * This guest session is explicitly designed to align with the business
 * requirement that 'reading is open to everyone' while maintaining the
 * separation between read and write operations. The guest account remains
 * active only for the duration of the session and is not tied to any persistent
 * user state. When the user attempts to perform any privileged action (like
 * joining a community), the system will prompt authentication, and the guest
 * session will be seamlessly replaced with a proper member account.
 *
 * Security is maintained by ensuring the guest account has no permissions
 * beyond read access and cannot be used for any form of content modification.
 * The guest session does not generate tokens that can be used to access any
 * edit or write endpoints, ensuring strict adherence to the requirement that
 * 'ownership is account-based.' The guest joining process is intentionally
 * limited to initiating session-based access without creating an account that
 * persists beyond the current browsing session.
 *
 * This operation must preceded by the user requesting access to the platform
 * and must be followed by any subsequent reads of content. After
 * authentication, the guest session is effectively replaced by a member
 * session, and all previous guest activities are isolated and non-persistent.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @accessor api.functional.auth.guest.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(connection: IConnection): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}

/**
 * Refreshes temporary guest session token to extend read-only access to public
 * content.
 *
 * This API operation extends the validity period of a Guest user session by
 * generating a new access token, enabling continuous read-only access to public
 * content without requiring re-authentication. The refresh operation is
 * essential for maintaining seamless user experience during extended browsing
 * sessions while preserving the security boundary that distinguishes guest
 * (unauthenticated) from member (authenticated) users.
 *
 * The refresh endpoint consumes a valid guest session token—typically acquired
 * via the /auth/guest/join endpoint—and returns a new token pair with updated
 * expiration timestamps. This mechanism allows users to remain in 'read-only'
 * mode for prolonged periods, aligning with the design principle that 'keep the
 * login session generously long.' The system tracks the guest's IP address and
 * timestamps to detect suspicious activity while maintaining user privacy.
 *
 * Because the guest role has no persistent identity or account state, the
 * refresh operation cannot reassign permissions or grant additional privileges.
 * It merely extends the life of the temporary, stateless session. When the user
 * attempts any privileged action (post, comment, vote, join), the system will
 * prompt authentication, at which point the guest session will be terminated
 * and replaced with a member session if credentials are valid.
 *
 * This operation does not affect any user's ability to participate in the
 * platform; it is purely a mechanism for maintaining read-only access to public
 * content. The refresh cycle is governed by the platform's security policies,
 * ensuring that guest sessions do not extend beyond reasonable limits, and does
 * not provide a mechanism to circumvent authentication requirements for
 * interactive features.
 *
 * @param props.connection
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @accessor api.functional.auth.guest.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (_connection: IConnection): Response => {
    return random();
  };
}
